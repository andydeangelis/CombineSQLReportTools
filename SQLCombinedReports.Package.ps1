#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 087317a2-0313-447d-a28b-5df2729d3b06
# Source File: C:\Scripts\Projects\SQLCombinedReports\SQLCombinedReports.psproj
#------------------------------------------------------------------------
#region Project Recovery Data (DO NOT MODIFY)
<#RecoveryData:
dhAAAB+LCAAAAAAABAC1mFtvmzAUx98r9TtEPE4iF9ItnZYitanSReolDahPkSYHDg2rYzPbpMk+
/Qw2NOklDZl5AY5z/uf88DH4kP4EAroEtr5EArnHR41Gf8zobwhEw1uTYM4oif9CeGYNEeZg5YPD
GAtgZ9aXZsI7P7LjQp1CdeqsFji/iPIjl0c1MgecNMVKWHkimeoBGI8pcZ1mu98qDP2bzAKjS7d9
2ut2esix291O1z456YU2ck5n9tcwcnrO97A7a3/rt7Szluo78NcJuDLwplkEpziU6bRZDrgDupjF
BLz76wkklAmfUsynw5QEQqJxmUj57aWr5j2VphewOBGvhYXJN6dmk12ajYs0xrJMbcv1BGIiTbKZ
VxPzkWfDmyOW1dZnqSztBCJgQAIobvfMGpElfQL7CtMZwr9kZS1XXfOszJ9EfyeeN6fP9g2KyZCy
hYwXWW5hZctlT1y9FHfwgrAHOOVylQ4oieJHhf5JcadvZHvc5CFMEEqEEeECSUdemW1bXhPjLQ0P
QMtVNRFNgNOUBVAZqhCa5spLgHFeDg/YMq5UzPfUxgn5OY6XFWZMC8xzlEu3CkspMs0zgRml4mfM
BWXr/Ym2ZKaZsjVQ/XW1qTJOdH99flUZ6EVUA88FCp7SpHLhXitrIDtgnmqbJc3iwyIZ05iIQ6hK
cQ18WatZiSkT1MBR7qFtpxLOhq4GKt0GVyLSGpM0PnD14Iz3I3nxN07hD8ZZxgocWvEZifNRuJdW
fKod8m1aIMGb/A/+35iXILe1hXTRdbuLdBMAzET4Mliu4Q/d5grzlYGoGndEImqCU4ZYqojcaQZ8
aWrRjEiA0xBudjY+pZPJ5XqN5Mgc2K7EhY/JvJ4MGKaymfQRf9qVfMvxDYEy1Jdl+dmsrDsWP8YE
4czhFi3AzbcK9WioBFn3mkhJv/XG9/io39r6n+EfJgyT8nYQAAA=#>
#endregion
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
     Generated on:       5/23/2018 9:36 AM
     Generated by:       andy-user
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2018
#>



#region Source: Startup.pss
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
6wMAACODCAAAAAAABAC9k0trg0AQx++FfgfJWdRlXU1AhdCQS+mDWtJeRx1l6T7C7prgt69NS1Jo
SUsOMpd5MPPjz8xkT1jrHZphBQ680bFcq3xGAzIrrq88L3swvOMKxJoLvAeJRenAuH4bbK3Nwh/V
Q8/SWpSV4GgP8SkzFOVgHUrf23yR4iD6MN+76YXrDeYKe2dA+N5jP06ob3F41m+o8ipNgdUsIQsa
YzRfZOFx5u+M4A4UdChRuWDZOy3BjcATmfyXTEnV0jlLoKFJjJT9TX7hqtF7G6y1kXYSrSsDe666
S1gRbVmbtoQ0LAIKZ1jS1toIXk2jaLzHSUCvUkwjiBusnTZDiWbHa7zoMM4v6xh+fl4Wfn/u4h27
t81y6wMAAA==#>
#endregion
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	#TODO: Add initialization script here (Load modules and check requirements)
	
	
	#--------------------------------------------------------------------------
	
	if((Show-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}







#endregion Source: Startup.pss

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	
	
#endregion Source: Globals.ps1

#region Source: MainForm.psf
function Show-MainForm_psf
{
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
KQsAACODCAAAAAAABABllscO80iShO8C9A6NuRIYOtEB/zZAb0VPiuSN3lvRP/1oei8LbJ0Kmag6
ZEV8FX/sPB33fLm4eI3/+m2+9Tj8z7/Qf8P/+vv5+OuvP8ZSl/UQd0Ld5Xrc53+/43oQxqX/9/Qt
/oD/r/3Pof/2/94+QAqzGHF5I02zBsfS/7sYmusCnbqRprSKBYiAk4RM/XDtm+YdFVOiapIXDHUq
WgvMPn7vjgiI8nZiYQI9HwsB+JGliftlcdzu9IN3OLs+7T5GIf71XQQ0dwtSKNE12PdTuOTgVRKi
Z3RYYNdkVvr7uhlORFH9WDwfM/d1A/zb4vF7Bqx4i2BpIBf7g4HAPBl7cktFBZVisSVTplg6GHa7
GKFlBF3ZodV51qyv69Oj6y616vNBJebNDhIkfibgMEU84+JT4hgpAFeuF4zgk+KQNZ7SdUeZoMLQ
nOppPGz+byC1RFQQV2MEm2av5CyP5yOiUiCk7MgcdZPLecbTcZrUBIV809JFiOR5jNjHwpBvdaxJ
4BRQJFYIxd7RxhzzKcgbNEPTco8CMrHPB5aPHDLxC0R59teBp0aqwiOqtySUOHuNzErX52yeW8Rt
TCFX7qKFM5467JwQMTkL2VvBOwR1YhU8hecjgMsbljJduOoROYm2Xu8aJidfbPTr9LJ3RvV0XsX3
Rm9EzNG1Dh+0AmcIR2+iPAtxOUxKtamJdFfI86Hq/bBNrQFMGFhIvMOyV0fCeRm+pRxGWM8BhkUb
pbLZBRlNF19PPfstlO8l75rBUE4jFTM5qGVRh7LnI1ZCC4d1TsDMOFGowMlN0ucV+SsOmV221deT
cc23nAAIlVXnh+E83Nbgr5p2FXBlBhItnNIkTlpq4efDBt+DvtNMNdJqYL+mhYw3Caa82tPJ730W
60v3CxVKXBieSarTOo188cVBelp0Afp6rhZpvjs7Sz1seT6EmU8ZYjKPfrgqzYyMUz3cSnHx6E5Y
tQ8XiXVg8HxJ4NnLryPXWyDAvATzimD7nirhwjss79aH2hD3+XgJirlc6qyrLBcuGb3bKzACK9ts
SPaCrkLkNT8DtoGYFiHn8J68pogj96uTKTHCoerOMB3j5DdTfanng0MS+SJGCPfXmIaHInZ22xyk
V1Zg/EuyiuyTqtF6bQDuSmN5ahKXhUzdc0ziH2dZUiSniR/zC+nj6D0fm1XgwnsqqeqGG6Z5r5/z
Ex2RP5hp6/bxQXafpdMrWidR+k4bgNQAL+Cbt1EWoTOrsdoEbtjIaJU20fMxVpPOXWBUA2huiSnG
uoCkM4tx9e0A5do30m5Hu/q0xZw7jmjvplQlNZAaxYXPDHWq4DXmdgm+P03582G45eRb+QUF1ipS
gbX3G45IlGfdkLutpe7eQW5CoyLNLZNUBj2ZlpWZpvH1AQ/r8GOjpHqxlKhnV/z5WBE3PJxs64Iv
2iRrAaBV4BvDwlMVGH6yW0tVy8DAHzyUlrXn8nCO0dU3NcwLFeQXfvGsYAkJ21MM/fnY114fIEeR
mVGtebtUmLsN0M2oj/bUMiHaDvhrRuhUEP/lK/LjK+LCrd15sIvQmAezE+evW3tva/rzAnRin5m+
RJZT1whD9Yw8TvAn22OJwcjJYEDR2ir7QUpKxvYF0jokkAYnGenAdVFobWak63AvR7Z7Yc8HeNIZ
rArxBx2VqAjFV39ICBC+Dx3gTxkIMwLEgBh/BahasPGWjG833nbnLR1V5318t7B7f7qOrsClHy1T
IChH/EXaAAfQSprwBDMgwOQ6FBZhnVN4Nit9XmIvTllQeqFumvLsM4273rfIBfNidI7r/lyVfcr0
p7eP3OUdPvKT1/d9YzEsrdhQ+7pNKBhvSTwD6mwllEYV5dJQmDYSHsUtU12L4AOMzLVuV8dRFcUY
xvR8NLw9pLwXlugOdYtmS/S9vD4BtGYUfGTHhmLoWXy6LHG3lPHCVWiCxFEHr/vWRj5alFPdas3m
NNODv19GZK75uO60YuAESCOKA6Il+eJxDe7jAeUYTXRRafD3xUFrnez4uQrn3F7wUkRz5Lov3J8y
zaUkOf6uz0eV6cjoIRplyErXynJT0CLbSj3jZL1uvljkJe5l4a23riUngTBANoHJ2XgZVSJHdLpr
rWtj3uSYH4C/N93TtdyGGcASb4pqIkFbOKkoouvU5mU1YTKXDmYiBtK8UDpU8LUmrddsdccESSys
kuJX5TgRsn2A/JF8nwIdqfAMj+JbBWSkrs4mweWxStbZ9AIjCKVTwIX9NARpiAXU3thyaY6lnR3t
a6Y6ObgV2Kue9i5+6g3q6wio/urBauBvsZg7H6Tn8RcSFuFeJH8bM3UzsQBNtb5HLQ1LJiCh5LXT
9HHxv2MFDC/0nPha0IPnY0BgMF/3kWSyHuYJnL9YLw3VhVqSt4aKrAhKZ1JvX37Vu/jtZTvMTHfW
h9yADBR9x4fc+P76daaX8rsNFQ6IrX+FED5ZRf8NpC4rQWS995fq3J1HGgJqTE71p93lOnX04/rV
IIxl6uwq4Ivr3drwSlJ3q4nxx953jHeo7r/RbTO2Elq86vPB213GA+WczaMeerpxajonjNYfz3Gy
gRc7AgbJF+5KSmk3eOSJVDPtyNzzUecKMDS6BX5geY3h5HozQc8XjJ22NzxakcdRNZqcWJ6VQfMB
sUmJrjuo1ia6MiFp71sV1JpxgLdz3s8Hi7rr2bCSBeLhd0idsMzgOCq5m4AuyYSqgbDR9KhyvfoE
V5EZQeN+co+Bo5kxHPDrmji1NwK2sm/r51Nh4AOBWIm6HLKaAvb8QjU3J6UBwbYTLCmdAkXcjghD
ycFuI3EHSnWcM14jlB+Jq9R7P9hdlMWrH/1oGUMDdhXCmoMftE3qq/bpHxKtFbVd4PwZbSABER/O
TVsROPY7AIdRioGIAUolxSlp+g/4T1T9J7TS32/eJ12df/8Cf5U/4P+Nxn//BwTYC8MpCwAA#>
#endregion
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Define SAPIEN Types
	#----------------------------------------------
	try{
		[FolderBrowserModernDialog] | Out-Null
	}
	catch
	{
		Add-Type -ReferencedAssemblies ('System.Windows.Forms') -TypeDefinition  @" 
		using System;
		using System.Windows.Forms;
		using System.Reflection;

        namespace SAPIENTypes
        {
		    public class FolderBrowserModernDialog : System.Windows.Forms.CommonDialog
            {
                private System.Windows.Forms.OpenFileDialog fileDialog;
                public FolderBrowserModernDialog()
                {
                    fileDialog = new System.Windows.Forms.OpenFileDialog();
                    fileDialog.Filter = "Folders|\n";
                    fileDialog.AddExtension = false;
                    fileDialog.CheckFileExists = false;
                    fileDialog.DereferenceLinks = true;
                    fileDialog.Multiselect = false;
                    fileDialog.Title = "Select a folder";
                }

                public string Title
                {
                    get { return fileDialog.Title; }
                    set { fileDialog.Title = value; }
                }

                public string InitialDirectory
                {
                    get { return fileDialog.InitialDirectory; }
                    set { fileDialog.InitialDirectory = value; }
                }
                
                public string SelectedPath
                {
                    get { return fileDialog.FileName; }
                    set { fileDialog.FileName = value; }
                }

                object InvokeMethod(Type type, object obj, string method, object[] parameters)
                {
                    MethodInfo methInfo = type.GetMethod(method, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                    return methInfo.Invoke(obj, parameters);
                }

                bool ShowOriginalBrowserDialog(IntPtr hwndOwner)
                {
                    using(FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog())
                    {
                        folderBrowserDialog.Description = this.Title;
                        folderBrowserDialog.SelectedPath = !string.IsNullOrEmpty(this.SelectedPath) ? this.SelectedPath : this.InitialDirectory;
                        folderBrowserDialog.ShowNewFolderButton = false;
                        if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
                        {
                            fileDialog.FileName = folderBrowserDialog.SelectedPath;
                            return true;
                        }
                        return false;
                    }
                }

                protected override bool RunDialog(IntPtr hwndOwner)
                {
                    if (Environment.OSVersion.Version.Major >= 6)
                    {      
                        try
                        {
                            bool flag = false;
                            System.Reflection.Assembly assembly = Assembly.Load("System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
                            Type typeIFileDialog = assembly.GetType("System.Windows.Forms.FileDialogNative").GetNestedType("IFileDialog", BindingFlags.NonPublic);
                            uint num = 0;
                            object dialog = InvokeMethod(fileDialog.GetType(), fileDialog, "CreateVistaDialog", null);
                            InvokeMethod(fileDialog.GetType(), fileDialog, "OnBeforeVistaDialog", new object[] { dialog });
                            uint options = (uint)InvokeMethod(typeof(System.Windows.Forms.FileDialog), fileDialog, "GetOptions", null) | (uint)0x20;
                            InvokeMethod(typeIFileDialog, dialog, "SetOptions", new object[] { options });
                            Type vistaDialogEventsType = assembly.GetType("System.Windows.Forms.FileDialog").GetNestedType("VistaDialogEvents", BindingFlags.NonPublic);
                            object pfde = Activator.CreateInstance(vistaDialogEventsType, fileDialog);
                            object[] parameters = new object[] { pfde, num };
                            InvokeMethod(typeIFileDialog, dialog, "Advise", parameters);
                            num = (uint)parameters[1];
                            try
                            {
                                int num2 = (int)InvokeMethod(typeIFileDialog, dialog, "Show", new object[] { hwndOwner });
                                flag = 0 == num2;
                            }
                            finally
                            {
                                InvokeMethod(typeIFileDialog, dialog, "Unadvise", new object[] { num });
                                GC.KeepAlive(pfde);
                            }
                            return flag;
                        }
                        catch
                        {
                            return ShowOriginalBrowserDialog(hwndOwner);
                        }
                    }
                    else
                        return ShowOriginalBrowserDialog(hwndOwner);
                }

                public override void Reset()
                {
                    fileDialog.Reset();
                }
            }
       }
"@ -IgnoreWarnings | Out-Null
	}
	#endregion Define SAPIEN Types

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$formCombinedSQLReporting = New-Object 'System.Windows.Forms.Form'
	$buttonCancel = New-Object 'System.Windows.Forms.Button'
	$buttonBack = New-Object 'System.Windows.Forms.Button'
	$buttonFinish = New-Object 'System.Windows.Forms.Button'
	$tabcontrolWizard = New-Object 'System.Windows.Forms.TabControl'
	$tabpageStep1 = New-Object 'System.Windows.Forms.TabPage'
	$buttonReportPath = New-Object 'System.Windows.Forms.Button'
	$textboxReportPath = New-Object 'System.Windows.Forms.TextBox'
	$labelReportOutputPath = New-Object 'System.Windows.Forms.Label'
	$datagridview2 = New-Object 'System.Windows.Forms.DataGridView'
	$buttonFileBrowse = New-Object 'System.Windows.Forms.Button'
	$textboxServerFileName = New-Object 'System.Windows.Forms.TextBox'
	$labelServerListFilePath = New-Object 'System.Windows.Forms.Label'
	$tabpageStep2 = New-Object 'System.Windows.Forms.TabPage'
	$checkboxDoNotSpecifySQLCrede = New-Object 'System.Windows.Forms.CheckBox'
	$buttonExecute1 = New-Object 'System.Windows.Forms.Button'
	$textboxSQLAccount = New-Object 'System.Windows.Forms.TextBox'
	$buttonSetSQLAccount = New-Object 'System.Windows.Forms.Button'
	$buttonSetDomainAccount = New-Object 'System.Windows.Forms.Button'
	$textboxDomainAccount = New-Object 'System.Windows.Forms.TextBox'
	$label1 = New-Object 'System.Windows.Forms.Label'
	$tabpageStep3 = New-Object 'System.Windows.Forms.TabPage'
	$buttonProgramBrowse = New-Object 'System.Windows.Forms.Button'
	$labelProgramOrScriptToRun = New-Object 'System.Windows.Forms.Label'
	$textboxProgramScript = New-Object 'System.Windows.Forms.TextBox'
	$buttonCreateTask = New-Object 'System.Windows.Forms.Button'
	$checkboxCreateScheduledTask = New-Object 'System.Windows.Forms.CheckBox'
	$buttonNext = New-Object 'System.Windows.Forms.Button'
	$openfiledialog1 = New-Object 'System.Windows.Forms.OpenFileDialog'
	$folderbrowsermoderndialog1 = New-Object 'SAPIENTypes.FolderBrowserModernDialog'
	$openfiledialog2 = New-Object 'System.Windows.Forms.OpenFileDialog'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	#-------------------------------------------------------
	# NOTE: When new TabPage added place the validation code
	# 		in the Test-WizardPage function.
	#-------------------------------------------------------
	function Test-WizardPage
	{
	<#
		Add TabPages and place the validation code in this function
	#>
		[OutputType([boolean])]
		param([System.Windows.Forms.TabPage]$tabPage)
		
		if($tabPage -eq $tabpageStep1)
		{
			#TODO: Enter Validation Code here for Step 1
			if ($textboxServerFileName.Text -and $textboxReportPath.Text)
			{
				return $true
			}
			
			return $false
		}
		elseif ($tabPage -eq $tabpageStep2)
		{
			#TODO: Enter Validation Code here for Step 2
			if ($textboxDomainAccount.Text -and $textboxSQLAccount.Text)
			{
				$buttonExecute1.Enabled = $true
				return $true
			}
			elseif ($textboxDomainAccount.Text -and $checkboxDoNotSpecifySQLCrede.Checked)
			{
				$buttonExecute1.Enabled = $true
				return $true
			}
			elseif (($textboxDomainAccount.Text -and (-not $textboxSQLAccount.Text)) -or ((-not $textboxDomainAccount.Text) -and (-not $checkboxDoNotSpecifySQLCrede.Checked)))
			{
				$buttonExecute1.Enabled = $false
				return $true
			}
			
			return $false
			
		}
		elseif ($tabPage -eq $tabpageStep3)
		{
			if ($checkboxCreateScheduledTask.Checked)
			{
				$textboxProgramScript.Enabled = $true
				$buttonProgramBrowse.Enabled = $true
				$buttonCreateTask.Enabled = $true
			}
			elseif (-not $checkboxCreateScheduledTask.Checked)
			{
				$textboxProgramScript.Enabled = $false
				$buttonProgramBrowse.Enabled = $false
				$buttonCreateTask.Enabled = $false
			}
			
		}
		
		#Add more pages here
		
		return $false
	}
	
	
	
	$buttonFinish_Click = {
		#TODO: Place custom script here
			
	}
	
	#region Events and Functions
	$formCombinedSQLReporting_Load={
		Update-NavButtons
	}
	
	function Update-NavButtons
	{
		<# 
			.DESCRIPTION
			Validates the current tab and Updates the Next, Prev and Finish buttons.
		#>
		$enabled = Test-WizardPage $tabcontrolWizard.SelectedTab
		$buttonNext.Enabled = $enabled -and ($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		$buttonBack.Enabled = $tabcontrolWizard.SelectedIndex -gt 0
		$buttonFinish.Enabled = $enabled -and ($tabcontrolWizard.SelectedIndex -eq $tabcontrolWizard.TabCount - 1)	
		#Uncomment to Hide Buttons
		#$buttonNext.Visible = ($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		#$buttonFinish.Visible = ($tabcontrolWizard.SelectedIndex -eq $tabcontrolWizard.TabCount - 1)
	}
	
	$script:DeselectedIndex = -1
	$tabcontrolWizard_Deselecting=[System.Windows.Forms.TabControlCancelEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TabControlCancelEventArgs]
		# Store the previous tab index
		$script:DeselectedIndex = $_.TabPageIndex
	}
	
	$tabcontrolWizard_Selecting=[System.Windows.Forms.TabControlCancelEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TabControlCancelEventArgs]
		# We only validate if we are moving to the Next TabPage. 
		# Users can move back without validating
		if($script:DeselectedIndex -ne -1 -and $script:DeselectedIndex -lt $_.TabPageIndex)
		{
			#Validate each page until we reach the one we want
			for($index = $script:DeselectedIndex; $index -lt $_.TabPageIndex; $index++)
			{
				$_.Cancel = -not (Test-WizardPage $tabcontrolWizard.TabPages[$index])
				
				if($_.Cancel) 
				{
					# Cancel and Return if validation failed.
					return;
				}
			}
		}
		
		Update-NavButtons
	}
	
	$buttonBack_Click={
		#Go to the previous tab page
		if($tabcontrolWizard.SelectedIndex -gt 0)
		{
			$tabcontrolWizard.SelectedIndex--
		}
	}
	
	$buttonNext_Click={	
		#Go to the next tab page
		if($tabcontrolWizard.SelectedIndex -lt $tabcontrolWizard.TabCount - 1)
		{
			$tabcontrolWizard.SelectedIndex++
		}
	}
	
	#endregion
	
	#------------------------------------------------------
	# NOTE: When a Control State changes you should call
	# 		Update-NavButtons to trigger validation
	#------------------------------------------------------
	
	$textboxServerFileName_TextChanged={
		Update-NavButtons
	}
	
	$openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
		#TODO: Place custom script here
		
	}
	
	$buttonFileBrowse_Click={
		
		# Open file dialog box for list of servers.
		
		$openfiledialog1.ShowDialog()
		$textboxServerFileName.Text = $openfiledialog1.FileName
		
		# Add the content of the servers file to the datagrid for Step 2.
		
		$servers = Get-Content ($openfiledialog1.FileName) | % {
			New-Object PSObject -Property @{
				"Server Name"  = $_
			}
		}
		
		$array = New-Object System.Collections.ArrayList
		$array.AddRange($servers)
		
		$datagridview2.DataSource = $array
	}
	
	#region Control Helper Functions
	function Update-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The DataGridView control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the DataGridView's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		.PARAMETER AutoSizeColumns
		    Resizes DataGridView control's columns after loading the items.
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember,
			[System.Windows.Forms.DataGridViewAutoSizeColumnMode]$AutoSizeColumns = 'None'
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
		{
			$DataGridView.DataSource = $Item.Tables[0]
		}
		elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{
				$array.Add($Item)
			}
			$DataGridView.DataSource = $array
		}
		
		if ($AutoSizeColumns -ne 'None')
		{
			$DataGridView.AutoResizeColumns($AutoSizeColumns)
		}
		
		$DataGridView.ResumeLayout()
	}
	
	function ConvertTo-DataTable
	{
		<#
			.SYNOPSIS
				Converts objects into a DataTable.
		
			.DESCRIPTION
				Converts objects into a DataTable, which are used for DataBinding.
		
			.PARAMETER  InputObject
				The input to convert into a DataTable.
		
			.PARAMETER  Table
				The DataTable you wish to load the input into.
		
			.PARAMETER RetainColumns
				This switch tells the function to keep the DataTable's existing columns.
			
			.PARAMETER FilterWMIProperties
				This switch removes WMI properties that start with an underline.
		
			.EXAMPLE
				$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
		#>
		[OutputType([System.Data.DataTable])]
		param(
		[ValidateNotNull()]
		$InputObject, 
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterWMIProperties)
		
		if($null -eq $Table)
		{
			$Table = New-Object System.Data.DataTable
		}
		
		if ($InputObject -is [System.Data.DataTable])
		{
			$Table = $InputObject
		}
		elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
		{
			$Table = $InputObject.Tables[0]
		}
		else
		{
			if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
			{
				#Clear out the Table Contents
				$Table.Clear()
				
				if ($null -eq $InputObject) { return } #Empty Data
				
				$object = $null
				#find the first non null value
				foreach ($item in $InputObject)
				{
					if ($null -ne $item)
					{
						$object = $item
						break
					}
				}
				
				if ($null -eq $object) { return } #All null then empty
				
				#Get all the properties in order to create the columns
				foreach ($prop in $object.PSObject.Get_Properties())
				{
					if (-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__')) #filter out WMI properties
					{
						#Get the type from the Definition string
						$type = $null
						
						if ($null -ne $prop.Value)
						{
							try { $type = $prop.Value.GetType() }
							catch { Out-Null }
						}
						
						if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
						{
							[void]$table.Columns.Add($prop.Name, $type)
						}
						else #Type info not found
						{
							[void]$table.Columns.Add($prop.Name)
						}
					}
				}
				
				if ($object -is [System.Data.DataRow])
				{
					foreach ($item in $InputObject)
					{
						$Table.Rows.Add($item)
					}
					return @( ,$Table)
				}
			}
			else
			{
				$Table.Rows.Clear()
			}
			
			foreach ($item in $InputObject)
			{
				$row = $table.NewRow()
				
				if ($item)
				{
					foreach ($prop in $item.PSObject.Get_Properties())
					{
						if ($table.Columns.Contains($prop.Name))
						{
							$row.Item($prop.Name) = $prop.Value
						}
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
		
		return @(,$Table)	
	}
	
	function Add-ListViewItem
	{
	<#
		.SYNOPSIS
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.DESCRIPTION
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.PARAMETER ListView
			The ListView control to add the items to.
	
		.PARAMETER Items
			The object or objects you wish to load into the ListView's Items collection.
			
		.PARAMETER  ImageIndex
			The index of a predefined image in the ListView's ImageList.
		
		.PARAMETER  SubItems
			List of strings to add as Subitems.
		
		.PARAMETER Group
			The group to place the item(s) in.
		
		.PARAMETER Clear
			This switch clears the ListView's Items before adding the new item(s).
		
		.EXAMPLE
			Add-ListViewItem -ListView $listview1 -Items "Test" -Group $listview1.Groups[0] -ImageIndex 0 -SubItems "Installed"
	#>
		
		Param( 
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.ListView]$ListView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Items,
		[int]$ImageIndex = -1,
		[string[]]$SubItems,
		$Group,
		[switch]$Clear)
		
		if($Clear)
		{
			$ListView.Items.Clear();
	    }
	    
	    $lvGroup = $null
	    if ($Group -is [System.Windows.Forms.ListViewGroup])
	    {
	        $lvGroup = $Group
	    }
	    elseif ($Group -is [string])
	    {
	        #$lvGroup = $ListView.Group[$Group] # Case sensitive
	        foreach ($groupItem in $ListView.Groups)
	        {
	            if ($groupItem.Name -eq $Group)
	            {
	                $lvGroup = $groupItem
	                break
	            }
	        }
	        
	        if ($null -eq $lvGroup)
	        {
	            $lvGroup = $ListView.Groups.Add($Group, $Group)
	        }
	    }
	    
		if($Items -is [Array])
		{
			$ListView.BeginUpdate()
			foreach ($item in $Items)
			{		
				$listitem  = $ListView.Items.Add($item.ToString(), $ImageIndex)
				#Store the object in the Tag
				$listitem.Tag = $item
				
				if($null -ne $SubItems)
				{
					$listitem.SubItems.AddRange($SubItems)
				}
				
				if($null -ne $lvGroup)
				{
					$listitem.Group = $lvGroup
				}
			}
			$ListView.EndUpdate()
		}
		else
		{
			#Add a new item to the ListView
			$listitem  = $ListView.Items.Add($Items.ToString(), $ImageIndex)
			#Store the object in the Tag
			$listitem.Tag = $Items
			
			if($null -ne $SubItems)
			{
				$listitem.SubItems.AddRange($SubItems)
			}
			
			if($null -ne $lvGroup)
			{
				$listitem.Group = $lvGroup
			}
		}
	}
	
	#endregion
	
	$datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
		#TODO: Place custom script here
		
	}
	
	$buttonSetDomainAccount_Click={
		
		$message = "The domain account you specify must be a member of the local Administrators group on each server."
		
		$global:domainCredButton = Get-Credential -Message $message
		$textboxDomainAccount.Text = $global:domainCredButton.UserName
		
		Update-NavButtons
	}
	
	$textboxDomainAccount_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$buttonSetSQLAccount_Click={
		
		$sqlMessage = "Please specify your SQL username and password."
		
		$global:sqlCredButton = Get-Credential -Message $sqlMessage
		$textboxSQLAccount.Text = $global:sqlCredButton.UserName	
		
		Update-NavButtons
	}
	
	$textboxSQLAccount_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$tabcontrolWizard_SelectedIndexChanged={
		#TODO: Place custom script here
		
	}
	
	$labelReportOutputPath_Click={
		#TODO: Place custom script here
		
	}
	
	$buttonReportPath_Click={
		
		# Open folder dialog box for list of servers.
		
		$folderbrowsermoderndialog1.ShowDialog()
		$textboxReportPath.Text = $folderbrowsermoderndialog1.SelectedPath
		
	}
	
	$textboxReportPath_TextChanged={
		
		Update-NavButtons
		
	}
	
	$datagridview2_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
		#TODO: Place custom script here
		
	}
	$buttonExecute1_Click={
		
		# Get current location for working directory.
		$wd = Get-Location
		
		# $servers = Get-Content $textboxServerFileName.ToString()
		$scriptFile = "$wd\CombineSQLReportTools\PS_SQL_DB_Info.ps1"
		
		# Export the SQL credentials to a temporary DPAPI XML file.
		
		# $sqlCredXMLFile = "$PSScriptRoot\sqlcred.xml"
		$sqlCredXMLFile = "$wd\sqlcred.xml"
		
		if ($checkboxDoNotSpecifySQLCrede.Checked -eq $true)
		{
			$null | Export-Clixml -Path $sqlCredXMLFile
		}
		Else
		{
			$global:sqlCredButton | Export-Clixml -Path $sqlCredXMLFile
		}
		
		# Export the Domain credentials to a temporary DPAPI XML file.
		
		# $domainCredXMLFile = "$PSScriptRoot\domaincred.xml"
		$domainCredXMLFile = "$wd\domaincred.xml"
		$global:domainCredButton | Export-Clixml -Path $domainCredXMLFile
		
		$argumentList = "-executionpolicy bypass", "-mta", "-noninteractive", "-windowstyle normal", "-nologo", "-file $scriptFile", $textboxServerFileName.Text, $textboxReportPath.Text, $sqlCredXMLFile, $domainCredXMLFile
		# $argumentList = $textboxServerFileName.Text, $textboxReportPath.Text, $sqlCredXMLFile
		
		# Invoke-Command -FilePath $scriptFile -ArgumentList $argumentList
		Start-Process powershell -WorkingDirectory $wd -ArgumentList $argumentList -NoNewWindow 
		
	}
	
	$checkboxDoNotSpecifySQLCrede_CheckedChanged={
		#TODO: Place custom script here
		
		Update-NavButtons
	}
	
	$buttonProgramBrowse_Click = {
		
		$openfiledialog2.ShowDialog()
		$textboxProgramScript.Text = $openfiledialog2.FileName
		
	}
	
	$checkboxCreateScheduledTask_CheckedChanged={
		#TODO: Place custom script here
		Update-NavButtons
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$formCombinedSQLReporting.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_textboxReportPath = $textboxReportPath.Text
		$script:MainForm_datagridview2 = $datagridview2.SelectedCells
		$script:MainForm_textboxServerFileName = $textboxServerFileName.Text
		$script:MainForm_checkboxDoNotSpecifySQLCrede = $checkboxDoNotSpecifySQLCrede.Checked
		$script:MainForm_textboxSQLAccount = $textboxSQLAccount.Text
		$script:MainForm_textboxDomainAccount = $textboxDomainAccount.Text
		$script:MainForm_textboxProgramScript = $textboxProgramScript.Text
		$script:MainForm_checkboxCreateScheduledTask = $checkboxCreateScheduledTask.Checked
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonBack.remove_Click($buttonBack_Click)
			$buttonFinish.remove_Click($buttonFinish_Click)
			$buttonReportPath.remove_Click($buttonReportPath_Click)
			$textboxReportPath.remove_TextChanged($textboxReportPath_TextChanged)
			$labelReportOutputPath.remove_Click($labelReportOutputPath_Click)
			$datagridview2.remove_CellContentClick($datagridview2_CellContentClick)
			$buttonFileBrowse.remove_Click($buttonFileBrowse_Click)
			$textboxServerFileName.remove_TextChanged($textboxServerFileName_TextChanged)
			$checkboxDoNotSpecifySQLCrede.remove_CheckedChanged($checkboxDoNotSpecifySQLCrede_CheckedChanged)
			$buttonExecute1.remove_Click($buttonExecute1_Click)
			$textboxSQLAccount.remove_TextChanged($textboxSQLAccount_TextChanged)
			$buttonSetSQLAccount.remove_Click($buttonSetSQLAccount_Click)
			$buttonSetDomainAccount.remove_Click($buttonSetDomainAccount_Click)
			$textboxDomainAccount.remove_TextChanged($textboxDomainAccount_TextChanged)
			$buttonProgramBrowse.remove_Click($buttonProgramBrowse_Click)
			$checkboxCreateScheduledTask.remove_CheckedChanged($checkboxCreateScheduledTask_CheckedChanged)
			$tabcontrolWizard.remove_SelectedIndexChanged($tabcontrolWizard_SelectedIndexChanged)
			$tabcontrolWizard.remove_Selecting($tabcontrolWizard_Selecting)
			$tabcontrolWizard.remove_Deselecting($tabcontrolWizard_Deselecting)
			$buttonNext.remove_Click($buttonNext_Click)
			$formCombinedSQLReporting.remove_Load($formCombinedSQLReporting_Load)
			$openfiledialog1.remove_FileOk($openfiledialog1_FileOk)
			$formCombinedSQLReporting.remove_Load($Form_StateCorrection_Load)
			$formCombinedSQLReporting.remove_Closing($Form_StoreValues_Closing)
			$formCombinedSQLReporting.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$formCombinedSQLReporting.SuspendLayout()
	$tabcontrolWizard.SuspendLayout()
	$tabpageStep1.SuspendLayout()
	$tabpageStep2.SuspendLayout()
	$tabpageStep3.SuspendLayout()
	#
	# formCombinedSQLReporting
	#
	$formCombinedSQLReporting.Controls.Add($buttonCancel)
	$formCombinedSQLReporting.Controls.Add($buttonBack)
	$formCombinedSQLReporting.Controls.Add($buttonFinish)
	$formCombinedSQLReporting.Controls.Add($tabcontrolWizard)
	$formCombinedSQLReporting.Controls.Add($buttonNext)
	$formCombinedSQLReporting.AcceptButton = $buttonFinish
	$formCombinedSQLReporting.AutoScaleDimensions = '6, 13'
	$formCombinedSQLReporting.AutoScaleMode = 'Font'
	$formCombinedSQLReporting.CancelButton = $buttonCancel
	$formCombinedSQLReporting.ClientSize = '537, 329'
	$formCombinedSQLReporting.FormBorderStyle = 'FixedDialog'
	$formCombinedSQLReporting.MaximizeBox = $False
	$formCombinedSQLReporting.Name = 'formCombinedSQLReporting'
	$formCombinedSQLReporting.StartPosition = 'CenterScreen'
	$formCombinedSQLReporting.Text = 'Combined SQL Reporting'
	$formCombinedSQLReporting.add_Load($formCombinedSQLReporting_Load)
	#
	# buttonCancel
	#
	$buttonCancel.Anchor = 'Bottom, Right'
	$buttonCancel.DialogResult = 'Cancel'
	$buttonCancel.Location = '369, 294'
	$buttonCancel.Name = 'buttonCancel'
	$buttonCancel.Size = '75, 23'
	$buttonCancel.TabIndex = 4
	$buttonCancel.Text = '&Cancel'
	$buttonCancel.UseCompatibleTextRendering = $True
	$buttonCancel.UseVisualStyleBackColor = $True
	#
	# buttonBack
	#
	$buttonBack.Anchor = 'Bottom, Left'
	$buttonBack.Location = '13, 294'
	$buttonBack.Name = 'buttonBack'
	$buttonBack.Size = '75, 23'
	$buttonBack.TabIndex = 1
	$buttonBack.Text = '< &Back'
	$buttonBack.UseCompatibleTextRendering = $True
	$buttonBack.UseVisualStyleBackColor = $True
	$buttonBack.add_Click($buttonBack_Click)
	#
	# buttonFinish
	#
	$buttonFinish.Anchor = 'Bottom, Right'
	$buttonFinish.DialogResult = 'OK'
	$buttonFinish.Location = '450, 294'
	$buttonFinish.Name = 'buttonFinish'
	$buttonFinish.Size = '75, 23'
	$buttonFinish.TabIndex = 3
	$buttonFinish.Text = '&Finish'
	$buttonFinish.UseCompatibleTextRendering = $True
	$buttonFinish.UseVisualStyleBackColor = $True
	$buttonFinish.add_Click($buttonFinish_Click)
	#
	# tabcontrolWizard
	#
	$tabcontrolWizard.Controls.Add($tabpageStep1)
	$tabcontrolWizard.Controls.Add($tabpageStep2)
	$tabcontrolWizard.Controls.Add($tabpageStep3)
	$tabcontrolWizard.Anchor = 'Top, Bottom, Left, Right'
	$tabcontrolWizard.Location = '13, 12'
	$tabcontrolWizard.Name = 'tabcontrolWizard'
	$tabcontrolWizard.SelectedIndex = 0
	$tabcontrolWizard.Size = '512, 276'
	$tabcontrolWizard.TabIndex = 0
	$tabcontrolWizard.add_SelectedIndexChanged($tabcontrolWizard_SelectedIndexChanged)
	$tabcontrolWizard.add_Selecting($tabcontrolWizard_Selecting)
	$tabcontrolWizard.add_Deselecting($tabcontrolWizard_Deselecting)
	#
	# tabpageStep1
	#
	$tabpageStep1.Controls.Add($buttonReportPath)
	$tabpageStep1.Controls.Add($textboxReportPath)
	$tabpageStep1.Controls.Add($labelReportOutputPath)
	$tabpageStep1.Controls.Add($datagridview2)
	$tabpageStep1.Controls.Add($buttonFileBrowse)
	$tabpageStep1.Controls.Add($textboxServerFileName)
	$tabpageStep1.Controls.Add($labelServerListFilePath)
	$tabpageStep1.Location = '4, 22'
	$tabpageStep1.Name = 'tabpageStep1'
	$tabpageStep1.Padding = '3, 3, 3, 3'
	$tabpageStep1.Size = '504, 250'
	$tabpageStep1.TabIndex = 0
	$tabpageStep1.Text = 'Step 1'
	$tabpageStep1.UseVisualStyleBackColor = $True
	#
	# buttonReportPath
	#
	$buttonReportPath.Location = '414, 47'
	$buttonReportPath.Name = 'buttonReportPath'
	$buttonReportPath.Size = '75, 23'
	$buttonReportPath.TabIndex = 6
	$buttonReportPath.Text = 'Browse...'
	$buttonReportPath.UseCompatibleTextRendering = $True
	$buttonReportPath.UseVisualStyleBackColor = $True
	$buttonReportPath.add_Click($buttonReportPath_Click)
	#
	# textboxReportPath
	#
	$textboxReportPath.Location = '137, 50'
	$textboxReportPath.Name = 'textboxReportPath'
	$textboxReportPath.ReadOnly = $True
	$textboxReportPath.Size = '259, 20'
	$textboxReportPath.TabIndex = 5
	$textboxReportPath.add_TextChanged($textboxReportPath_TextChanged)
	#
	# labelReportOutputPath
	#
	$labelReportOutputPath.AutoSize = $True
	$labelReportOutputPath.Location = '9, 50'
	$labelReportOutputPath.Name = 'labelReportOutputPath'
	$labelReportOutputPath.Size = '105, 17'
	$labelReportOutputPath.TabIndex = 4
	$labelReportOutputPath.Text = 'Report Output Path:'
	$labelReportOutputPath.UseCompatibleTextRendering = $True
	$labelReportOutputPath.add_Click($labelReportOutputPath_Click)
	#
	# datagridview2
	#
	$datagridview2.AllowUserToDeleteRows = $False
	$datagridview2.AutoSizeColumnsMode = 'Fill'
	$datagridview2.ColumnHeadersHeightSizeMode = 'AutoSize'
	$datagridview2.Location = '0, 86'
	$datagridview2.Name = 'datagridview2'
	$datagridview2.ReadOnly = $True
	$datagridview2.Size = '504, 164'
	$datagridview2.TabIndex = 3
	$datagridview2.add_CellContentClick($datagridview2_CellContentClick)
	#
	# buttonFileBrowse
	#
	$buttonFileBrowse.Location = '414, 9'
	$buttonFileBrowse.Name = 'buttonFileBrowse'
	$buttonFileBrowse.Size = '75, 23'
	$buttonFileBrowse.TabIndex = 2
	$buttonFileBrowse.Text = 'Browse...'
	$buttonFileBrowse.UseCompatibleTextRendering = $True
	$buttonFileBrowse.UseVisualStyleBackColor = $True
	$buttonFileBrowse.add_Click($buttonFileBrowse_Click)
	#
	# textboxServerFileName
	#
	$textboxServerFileName.Location = '137, 11'
	$textboxServerFileName.Name = 'textboxServerFileName'
	$textboxServerFileName.ReadOnly = $True
	$textboxServerFileName.Size = '259, 20'
	$textboxServerFileName.TabIndex = 1
	$textboxServerFileName.add_TextChanged($textboxServerFileName_TextChanged)
	#
	# labelServerListFilePath
	#
	$labelServerListFilePath.AutoSize = $True
	$labelServerListFilePath.Location = '9, 14'
	$labelServerListFilePath.Name = 'labelServerListFilePath'
	$labelServerListFilePath.Size = '109, 17'
	$labelServerListFilePath.TabIndex = 0
	$labelServerListFilePath.Text = 'Server List File Path:'
	$labelServerListFilePath.UseCompatibleTextRendering = $True
	#
	# tabpageStep2
	#
	$tabpageStep2.Controls.Add($checkboxDoNotSpecifySQLCrede)
	$tabpageStep2.Controls.Add($buttonExecute1)
	$tabpageStep2.Controls.Add($textboxSQLAccount)
	$tabpageStep2.Controls.Add($buttonSetSQLAccount)
	$tabpageStep2.Controls.Add($buttonSetDomainAccount)
	$tabpageStep2.Controls.Add($textboxDomainAccount)
	$tabpageStep2.Controls.Add($label1)
	$tabpageStep2.Location = '4, 22'
	$tabpageStep2.Name = 'tabpageStep2'
	$tabpageStep2.Padding = '3, 3, 3, 3'
	$tabpageStep2.Size = '504, 250'
	$tabpageStep2.TabIndex = 1
	$tabpageStep2.Text = 'Step 2'
	$tabpageStep2.UseVisualStyleBackColor = $True
	#
	# checkboxDoNotSpecifySQLCrede
	#
	$checkboxDoNotSpecifySQLCrede.Location = '185, 100'
	$checkboxDoNotSpecifySQLCrede.Name = 'checkboxDoNotSpecifySQLCrede'
	$checkboxDoNotSpecifySQLCrede.Size = '136, 35'
	$checkboxDoNotSpecifySQLCrede.TabIndex = 6
	$checkboxDoNotSpecifySQLCrede.Text = 'Do not specify SQL credentials'
	$checkboxDoNotSpecifySQLCrede.UseCompatibleTextRendering = $True
	$checkboxDoNotSpecifySQLCrede.UseVisualStyleBackColor = $True
	$checkboxDoNotSpecifySQLCrede.add_CheckedChanged($checkboxDoNotSpecifySQLCrede_CheckedChanged)
	#
	# buttonExecute1
	#
	$buttonExecute1.Enabled = $False
	$buttonExecute1.Location = '22, 204'
	$buttonExecute1.Name = 'buttonExecute1'
	$buttonExecute1.Size = '146, 23'
	$buttonExecute1.TabIndex = 5
	$buttonExecute1.Text = 'Execute Data Collection'
	$buttonExecute1.UseCompatibleTextRendering = $True
	$buttonExecute1.UseVisualStyleBackColor = $True
	$buttonExecute1.add_Click($buttonExecute1_Click)
	#
	# textboxSQLAccount
	#
	$textboxSQLAccount.Location = '22, 73'
	$textboxSQLAccount.Name = 'textboxSQLAccount'
	$textboxSQLAccount.ReadOnly = $True
	$textboxSQLAccount.Size = '146, 20'
	$textboxSQLAccount.TabIndex = 4
	$textboxSQLAccount.add_TextChanged($textboxSQLAccount_TextChanged)
	#
	# buttonSetSQLAccount
	#
	$buttonSetSQLAccount.Location = '185, 71'
	$buttonSetSQLAccount.Name = 'buttonSetSQLAccount'
	$buttonSetSQLAccount.Size = '136, 23'
	$buttonSetSQLAccount.TabIndex = 3
	$buttonSetSQLAccount.Text = 'Set SQL Account'
	$buttonSetSQLAccount.UseCompatibleTextRendering = $True
	$buttonSetSQLAccount.UseVisualStyleBackColor = $True
	$buttonSetSQLAccount.add_Click($buttonSetSQLAccount_Click)
	#
	# buttonSetDomainAccount
	#
	$buttonSetDomainAccount.Location = '185, 27'
	$buttonSetDomainAccount.Name = 'buttonSetDomainAccount'
	$buttonSetDomainAccount.Size = '136, 23'
	$buttonSetDomainAccount.TabIndex = 2
	$buttonSetDomainAccount.Text = 'Set Domain Account'
	$buttonSetDomainAccount.UseCompatibleTextRendering = $True
	$buttonSetDomainAccount.UseVisualStyleBackColor = $True
	$buttonSetDomainAccount.add_Click($buttonSetDomainAccount_Click)
	#
	# textboxDomainAccount
	#
	$textboxDomainAccount.Location = '22, 28'
	$textboxDomainAccount.Name = 'textboxDomainAccount'
	$textboxDomainAccount.ReadOnly = $True
	$textboxDomainAccount.Size = '146, 20'
	$textboxDomainAccount.TabIndex = 1
	$textboxDomainAccount.add_TextChanged($textboxDomainAccount_TextChanged)
	#
	# label1
	#
	$label1.AutoSize = $True
	$label1.Location = '-30, 43'
	$label1.Name = 'label1'
	$label1.Size = '35, 17'
	$label1.TabIndex = 0
	$label1.Text = 'label1'
	$label1.UseCompatibleTextRendering = $True
	#
	# tabpageStep3
	#
	$tabpageStep3.Controls.Add($buttonProgramBrowse)
	$tabpageStep3.Controls.Add($labelProgramOrScriptToRun)
	$tabpageStep3.Controls.Add($textboxProgramScript)
	$tabpageStep3.Controls.Add($buttonCreateTask)
	$tabpageStep3.Controls.Add($checkboxCreateScheduledTask)
	$tabpageStep3.Location = '4, 22'
	$tabpageStep3.Name = 'tabpageStep3'
	$tabpageStep3.Padding = '3, 3, 3, 3'
	$tabpageStep3.Size = '504, 250'
	$tabpageStep3.TabIndex = 2
	$tabpageStep3.Text = 'Step 3'
	$tabpageStep3.UseVisualStyleBackColor = $True
	#
	# buttonProgramBrowse
	#
	$buttonProgramBrowse.Location = '279, 56'
	$buttonProgramBrowse.Name = 'buttonProgramBrowse'
	$buttonProgramBrowse.Size = '75, 23'
	$buttonProgramBrowse.TabIndex = 4
	$buttonProgramBrowse.Text = 'Browse...'
	$buttonProgramBrowse.UseCompatibleTextRendering = $True
	$buttonProgramBrowse.UseVisualStyleBackColor = $True
	$buttonProgramBrowse.add_Click($buttonProgramBrowse_Click)
	#
	# labelProgramOrScriptToRun
	#
	$labelProgramOrScriptToRun.AutoSize = $True
	$labelProgramOrScriptToRun.Location = '23, 61'
	$labelProgramOrScriptToRun.Name = 'labelProgramOrScriptToRun'
	$labelProgramOrScriptToRun.Size = '132, 17'
	$labelProgramOrScriptToRun.TabIndex = 3
	$labelProgramOrScriptToRun.Text = 'Program or Script to Run:'
	$labelProgramOrScriptToRun.UseCompatibleTextRendering = $True
	#
	# textboxProgramScript
	#
	$textboxProgramScript.Location = '173, 58'
	$textboxProgramScript.Name = 'textboxProgramScript'
	$textboxProgramScript.Size = '100, 20'
	$textboxProgramScript.TabIndex = 2
	#
	# buttonCreateTask
	#
	$buttonCreateTask.Location = '7, 216'
	$buttonCreateTask.Name = 'buttonCreateTask'
	$buttonCreateTask.Size = '75, 23'
	$buttonCreateTask.TabIndex = 1
	$buttonCreateTask.Text = 'Create Task'
	$buttonCreateTask.UseCompatibleTextRendering = $True
	$buttonCreateTask.UseVisualStyleBackColor = $True
	#
	# checkboxCreateScheduledTask
	#
	$checkboxCreateScheduledTask.Location = '23, 18'
	$checkboxCreateScheduledTask.Name = 'checkboxCreateScheduledTask'
	$checkboxCreateScheduledTask.Size = '145, 24'
	$checkboxCreateScheduledTask.TabIndex = 0
	$checkboxCreateScheduledTask.Text = 'Create Scheduled Task'
	$checkboxCreateScheduledTask.UseCompatibleTextRendering = $True
	$checkboxCreateScheduledTask.UseVisualStyleBackColor = $True
	$checkboxCreateScheduledTask.add_CheckedChanged($checkboxCreateScheduledTask_CheckedChanged)
	#
	# buttonNext
	#
	$buttonNext.Anchor = 'Bottom, Right'
	$buttonNext.Location = '288, 294'
	$buttonNext.Name = 'buttonNext'
	$buttonNext.Size = '75, 23'
	$buttonNext.TabIndex = 2
	$buttonNext.Text = '&Next >'
	$buttonNext.UseCompatibleTextRendering = $True
	$buttonNext.UseVisualStyleBackColor = $True
	$buttonNext.add_Click($buttonNext_Click)
	#
	# openfiledialog1
	#
	$openfiledialog1.FileName = 'openfiledialog1'
	$openfiledialog1.add_FileOk($openfiledialog1_FileOk)
	#
	# folderbrowsermoderndialog1
	#
	#
	# openfiledialog2
	#
	$openfiledialog2.FileName = 'openfiledialog2'
	$tabpageStep3.ResumeLayout()
	$tabpageStep2.ResumeLayout()
	$tabpageStep1.ResumeLayout()
	$tabcontrolWizard.ResumeLayout()
	$formCombinedSQLReporting.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $formCombinedSQLReporting.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$formCombinedSQLReporting.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$formCombinedSQLReporting.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$formCombinedSQLReporting.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $formCombinedSQLReporting.ShowDialog()

}
#endregion Source: MainForm.psf

#region Source: CombineSQLReportTools\Functions\Get-ClusterConfig.ps1
function Invoke-Get-ClusterConfig_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-ClusterConfig function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         While it's true that using the FailOver cluster PS module would be leaps and bounds easier, you may end up running this from a 
	#         server that does not have that module installed. The purpose of this script is to help gather information about the various clusters 
	#         and build an Excel report that outputs the configuration. This function can be used independently.
	#    Usage: 
	#           - The ClusterName parameter is a string.
	#    Examples:
	#               . .\Get-ClusterConfig.ps1
	#
	#               Get-ClusterConfig -ClusterNames $clusterName
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	# While it's true that using the FailOver cluster PS module would be leaps and bounds easier, you may end up running this from a server that does not have it.
	# As such, we will be using WMI to grab initial cluster data.
	
	function Get-ClusterConfig
	{
	    # This is the -ClusterName parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	    Param(
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			$ClusterNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	    )
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		# Two script blocks are defined here. The first script block uses the the user credentials of the running user.
		# The second script block runs the same commands, but passes the specified domain credential object to query WMI.
	
	    $getClConfigScript = {
	
	        Param ($ClusterName,$parent)
	
	        # Let's get some cluster data from WMI. The first variable pulls the running cluster config.
	        
	        $clData = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_cluster
	        
	        # This next variable will hold the core cluster DNS name.
	        $clCoreDNS = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_resource | 
	                    where-object {($_.OwnerGroup -eq "Cluster Group") -and ($_.Type -eq "Network Name")} | 
	                    Select Type, OwnerGroup, CoreResource -ExpandProperty PrivateProperties
	                    
	        # This next variable will hold the core cluster IP Address.
	        $clCoreIP = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_resource | 
	                    where-object {($_.OwnerGroup -eq "Cluster Group") -and ($_.Type -eq "IP Address")} | 
	                    Select Type, OwnerGroup, CoreResource -ExpandProperty PrivateProperties
	        
	        # Create a new PSObject so we can add all the data for each cluster.  
	        $clObject = New-Object System.Object
	        
	        $clObject | Add-Member -Type NoteProperty -Name Name -Value $clData.Name
	        $clObject | Add-Member -Type NoteProperty -Name FQDN -Value $clData.FQDN
	        $clObject | Add-Member -Type NoteProperty -Name "DNS Name" $clCoreDNS.DNSName
	        $clObject | Add-Member -Type NoteProperty -Name "DNS Suffix" $clCoreDNS.DNSSuffix
	        $clObject | Add-Member -Type NoteProperty -Name "IP Address" $clCoreIP.Address
	        $clObject | Add-Member -Type NoteProperty -Name "Subnet Mask" $clCoreIP.SubnetMask
	        $clObject | Add-Member -Type NoteProperty -Name "Enable DHCP" $clCoreIP.EnableDHCP
	        $clObject | Add-Member -Type NoteProperty -Name "Network" $clCoreIP.Network
	        $clObject | Add-Member -Type NoteProperty -Name ClusterLogLevel -Value $clData.ClusterLogLevel
	        $clObject | Add-Member -Type NoteProperty -Name SharedVolumesRoot -Value $clData.SharedVolumesRoot
	        $clObject | Add-Member -Type NoteProperty -Name QuorumType -Value $clData.QuorumType
	        $clObject | Add-Member -Type NoteProperty -Name QuorumPath -Value $clData.QuorumPath
	        $clObject | Add-Member -Type NoteProperty -Name SameSubnetDelay -Value $clData.SameSubnetDelay
	        $clObject | Add-Member -Type NoteProperty -Name SameSubnetThreshold -Value $clData.SameSubnetThreshold
	        $clObject | Add-Member -Type NoteProperty -Name CrossSubnetDelay -Value $clData.CrossSubnetDelay
	        $clObject | Add-Member -Type NoteProperty -Name CrossSubnetThreshold -Value $clData.CrossSubnetThreshold
	        
	        # Return the core cluster config as an object.
	
	        $clObject
			
			
		}
		
		$getClConfigScriptDomain = {
			
			Param ($ClusterName,$parent,$credentials)
			
			# Let's get some cluster data from WMI. The first variable pulls the running cluster config.
			
			$clData = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_cluster -Credential $credentials
			
			# This next variable will hold the core cluster DNS name.
			$clCoreDNS = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_resource -Credential $credentials |
			where-object { ($_.OwnerGroup -eq "Cluster Group") -and ($_.Type -eq "Network Name") } |
			Select Type, OwnerGroup, CoreResource -ExpandProperty PrivateProperties
			
			# This next variable will hold the core cluster IP Address.
			$clCoreIP = Get-WmiObject -Namespace root\mscluster -ComputerName $ClusterName -Class mscluster_resource -Credential $credentials |
			where-object { ($_.OwnerGroup -eq "Cluster Group") -and ($_.Type -eq "IP Address") } |
			Select Type, OwnerGroup, CoreResource -ExpandProperty PrivateProperties
			
			# Create a new PSObject so we can add all the data for each cluster.  
			$clObject = New-Object System.Object
			
			$clObject | Add-Member -Type NoteProperty -Name Name -Value $clData.Name
			$clObject | Add-Member -Type NoteProperty -Name FQDN -Value $clData.FQDN
			$clObject | Add-Member -Type NoteProperty -Name "DNS Name" $clCoreDNS.DNSName
			$clObject | Add-Member -Type NoteProperty -Name "DNS Suffix" $clCoreDNS.DNSSuffix
			$clObject | Add-Member -Type NoteProperty -Name "IP Address" $clCoreIP.Address
			$clObject | Add-Member -Type NoteProperty -Name "Subnet Mask" $clCoreIP.SubnetMask
			$clObject | Add-Member -Type NoteProperty -Name "Enable DHCP" $clCoreIP.EnableDHCP
			$clObject | Add-Member -Type NoteProperty -Name "Network" $clCoreIP.Network
			$clObject | Add-Member -Type NoteProperty -Name ClusterLogLevel -Value $clData.ClusterLogLevel
			$clObject | Add-Member -Type NoteProperty -Name SharedVolumesRoot -Value $clData.SharedVolumesRoot
			$clObject | Add-Member -Type NoteProperty -Name QuorumType -Value $clData.QuorumType
			$clObject | Add-Member -Type NoteProperty -Name QuorumPath -Value $clData.QuorumPath
			$clObject | Add-Member -Type NoteProperty -Name SameSubnetDelay -Value $clData.SameSubnetDelay
			$clObject | Add-Member -Type NoteProperty -Name SameSubnetThreshold -Value $clData.SameSubnetThreshold
			$clObject | Add-Member -Type NoteProperty -Name CrossSubnetDelay -Value $clData.CrossSubnetDelay
			$clObject | Add-Member -Type NoteProperty -Name CrossSubnetThreshold -Value $clData.CrossSubnetThreshold
			
			# Return the core cluster config as an object.
			
			$clObject	
			
		}
		
		# For each server, start a separate runspace job.
	
	  $Throttle = 8
	  $clConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $clConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$clConfigInitialSessionState,$Host)
	  $clConfigRunspacePool.Open()
	  $clConfigJobs = @()
	
	  foreach ($cluster in $ClusterNames)
		{
			# Test of the $domainCredential paramter is passed and call the appropriate script block.
			# If yes, pass the domain credential object to the script block to run WMI.
			# If no, call the script block and run as the executing user.
			
			if ($domainCredential)
			{
				$clConfigJob = [powershell]::Create().AddScript($getClConfigScriptDomain).AddArgument($cluster).AddArgument($parent).AddArgument($domainCredential)
				$clConfigJob.RunspacePool = $clConfigRunspacePool
				$clConfigJobs += New-Object PSObject -Property @{
					Pipe	 = $clConfigJob
					Result   = $clConfigJob.BeginInvoke()
				}
			}
			else
			{
				$clConfigJob = [powershell]::Create().AddScript($getClConfigScript).AddArgument($cluster).AddArgument($parent)
				$clConfigJob.RunspacePool = $clConfigRunspacePool
				$clConfigJobs += New-Object PSObject -Property @{
					Pipe	  = $clConfigJob
					Result    = $clConfigJob.BeginInvoke()
				}
			}
		}
		
		$clConfigResults = @()  
	
	  Write-Host "Getting cluster configuration..." -NoNewline -ForegroundColor Green
	
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 200
	  } while ($clConfigJobs.Result.IsCompleted -contains $false)
	
	  ForEach ($clConfigJob in $clConfigJobs) 
	  {       
	    $clConfigResults += $clConfigJob.Pipe.EndInvoke($clConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	# $Results | Out-GridView
	  $clConfigRunspacePool.Close()
	  $clConfigRunspacePool.Dispose()
	
	  return $clConfigResults
	        
	        
	}
}
#endregion Source: Get-ClusterConfig.ps1

#region Source: CombineSQLReportTools\Functions\Get-ClusteredSQLInstances.ps1
function Invoke-Get-ClusteredSQLInstances_ps1
{
	function Get-ClusteredSQLInstances
	{
	    # This is the -Computername parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	    # The parameter can be a single name or list of names.
	
	    Param(
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			$ClusterNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $true)]
			$domainCredential
	    )
	
	    . "$PSScriptRoot\Get-SQLInstances02.ps1"
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		# Four script blocks are defined here.
		# If SQL Server cluster object types are found, the $getClSQLScript or $getClSQLScriptDomain script block is called.
		# Which block is called is determined by if the $domainCred parameter is passed.
		# If no clustered SQL objects are found, assume this is an availability group and call either the $getAGSQLScript or $getAGSQLScriptDomain script blocks.
		# Which block is called is determined by if the $domainCred parameter is passed.
	
	    $getClSQLScript = {
	
	        Param ($cluster,$parent)
	
	        # Get the private properties for the SQL Server cluster resource type.
	        # Write-Host $cluster -ForegroundColor Yellow
	        $sqlSvrResource = (Get-WmiObject -Namespace root\mscluster -Class MSCluster_Resource -ComputerName $cluster | Where-Object {$_.Type -eq 'SQL Server'} | select -Expand PrivateProperties)
	      
	        If ($sqlSvrResource -ne $null)
	        {
	            foreach ($instance in $sqlSvrResource)
	            {
	                $clInstanceNames += @($instance.VirtualServerName + "\" + $instance.InstanceName)
	                # Write-Host "Cluster " $cluster.Name " has the following SQL instances." -ForegroundColor Green
	                # $clInstanceName     
	                # $clInstanceNameList += @("$clInstanceName")
	            }
	            $clInstanceNames
	        }
	    }
	
	    $getAGSQLScript ={
	
	        param ($cluster,$parent)
	
	      # We know clustering is installed, but we have no 'SQL Server' type clustered resources.' We're going to check for instances of SQL now.
	      # First thing, let's get the nodes of the cluster.
	        
	      $clNodes = get-wmiobject -Class MSCluster_node -Namespace root\mscluster -ComputerName $cluster | select Name
	        
	      foreach ($node in $clNodes)
	      {
	        # Now, let's check to see if SQL is on these nodes.
	          
	        $clInstanceNames += @(Get-SQLInstances02 -ComputerName $node.Name)        
	      }
	      $clInstanceNames
	    }
		
		$getClSQLScriptDomain = {
			
			Param ($cluster,
				$parent,
				$domainCred)
			
			# Get the private properties for the SQL Server cluster resource type.
			# Write-Host $cluster -ForegroundColor Yellow
			$sqlSvrResource = (Get-WmiObject -Namespace root\mscluster -Class MSCluster_Resource -ComputerName $cluster -Credential $domainCred | Where-Object { $_.Type -eq 'SQL Server' } | select -Expand PrivateProperties)
			
			If ($sqlSvrResource -ne $null)
			{
				foreach ($instance in $sqlSvrResource)
				{
					$clInstanceNames += @($instance.VirtualServerName + "\" + $instance.InstanceName)
					# Write-Host "Cluster " $cluster.Name " has the following SQL instances." -ForegroundColor Green
					# $clInstanceName     
					# $clInstanceNameList += @("$clInstanceName")
				}
				$clInstanceNames
			}
		}
		
		$getAGSQLScriptDomain = {
			
			param ($cluster,
				$parent,
				$domainCred)
			
			# We know clustering is installed, but we have no 'SQL Server' type clustered resources.' We're going to check for instances of SQL now.
			# First thing, let's get the nodes of the cluster.
			
			$clNodes = get-wmiobject -Class MSCluster_node -Namespace root\mscluster -ComputerName $cluster -Credential $domainCred | select Name
			
			foreach ($node in $clNodes)
			{
				# Now, let's check to see if SQL is on these nodes.
				
				$clInstanceNames += @(Get-SQLInstances02 -ComputerName $node.Name -domainCredential $domainCred)
			}
			$clInstanceNames
		}
		
		$Throttle = 8
		$clSQLInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	
		$definition = Get-Content Function:\Get-SQLInstances02 -ErrorAction Stop   
		$GetSQLInstancesSessionStateFunction = New-Object System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList 'Get-SQLInstances02', $definition
		$clSQLInitialSessionState.Commands.Add($GetSQLInstancesSessionStateFunction)
	
		$clSQLRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$clSQLInitialSessionState,$Host)
		$clSQLRunspacePool.Open()
		$clSQLJobs = @()
		
		Write-Host "Getting clustered SQL configuration..." -NoNewline -ForegroundColor Green
		
		foreach ($cluster in $ClusterNames)
		{
			# First, test to see if clustered SQL Server object types are found.
			if ($domainCredential)
			{
				$testClusteredSQLInstance = (Get-WmiObject -Namespace root\mscluster -Class MSCluster_Resource -ComputerName $cluster -Credential $domainCredential | Where-Object { $_.Type -eq 'SQL Server' })
			}
			else
			{
				$testClusteredSQLInstance = (Get-WmiObject -Namespace root\mscluster -Class MSCluster_Resource -ComputerName $cluster | Where-Object { $_.Type -eq 'SQL Server' })
			}
			
			# If clustered SQL Server object types are found, run the getClSQLScript or getClSQLScriptDomain script block.
			
			if ($testClusteredSQLInstance -ne $null)
			{
				# Test of the $domainCred paramter is passed and call the appropriate script block.
				# If yes, pass the domain credential object to the script block to run WMI.
				# If no, call the script block and run as the executing user.
				
				if ($domainCredential)
				{
					$clSQLJob = [powershell]::Create().AddScript($getClSQLScriptDomain).AddArgument($cluster).AddArgument($parent).AddArgument($domainCredential)
					$clSQLJob.RunspacePool = $clSQLRunspacePool
					$clSQLJobs += New-Object PSObject -Property @{
						Pipe	  = $clSQLJob
						Result    = $clSQLJob.BeginInvoke()
					}
				}
				else
				{
					$clSQLJob = [powershell]::Create().AddScript($getClSQLScript).AddArgument($cluster).AddArgument($parent)
					$clSQLJob.RunspacePool = $clSQLRunspacePool
					$clSQLJobs += New-Object PSObject -Property @{
						Pipe	   = $clSQLJob
						Result	   = $clSQLJob.BeginInvoke()
					}
				}
			}
			elseif ($testClusteredSQLInstance -eq $null)
			{
				# Test of the $domainCred paramter is passed and call the appropriate script block.
				# If yes, pass the domain credential object to the script block to run WMI.
				# If no, call the script block and run as the executing user.		
				
				if ($domainCredential)
				{
					$clSQLJob = [powershell]::Create().AddScript($getAGSQLScriptDomain).AddArgument($cluster).AddArgument($parent).AddArgument($domainCredential)
					$clSQLJob.RunspacePool = $clSQLRunspacePool
					$clSQLJobs += New-Object PSObject -Property @{
						Pipe	   = $clSQLJob
						Result	   = $clSQLJob.BeginInvoke()
					}
				}
				else
				{
					$clSQLJob = [powershell]::Create().AddScript($getAGSQLScript).AddArgument($cluster).AddArgument($parent)
					$clSQLJob.RunspacePool = $clSQLRunspacePool
					$clSQLJobs += New-Object PSObject -Property @{
						Pipe	   = $clSQLJob
						Result	   = $clSQLJob.BeginInvoke()
					}
				}
			}
			
		}
	
		$clSQLResults = @()  
	  
		Do
		{
			Write-Host "." -NoNewline -ForegroundColor Green
			Start-Sleep -Milliseconds 200
		} while ($clSQLJobs.Result.IsCompleted -contains $false)
	
		ForEach ($clSQLJob in $clSQLJobs) 
		{       
			$clSQLResults += $clSQLJob.Pipe.EndInvoke($clSQLJob.Result)
		}
	
		Write-Host "All jobs completed!" -ForegroundColor Green
	
		$clSQLRunspacePool.Close()
		$clSQLRunspacePool.Dispose()
	
		return $clSQLResults
	    
	}
}
#endregion Source: Get-ClusteredSQLInstances.ps1

#region Source: CombineSQLReportTools\Functions\Get-ClusterNodes.ps1
function Invoke-Get-ClusterNodes_ps1
{
	# While it's true that using the FailOver cluster PS module would be leaps and bounds easier, you may end up running this from a server that does not have it.
	# As such, we will be using WMI to grab initial cluster data.
	
	function Get-ClusterNodes
	{
	    # This is the -ClusterNames parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	    Param(
	        [parameter(Mandatory=$true,ValueFromPipeline=$True)] $ClusterNames,
	        [parameter(Mandatory=$true,ValueFromPipeline=$True)] $Path
	    )
	
	    # Need to add error handling here (try/catch).
	
	    foreach ($cluster in $ClusterNames)
	    {
	        $clServerConfigResult = @()
	        # $clServerDiskCOnfig = @()
	        # $clServerOS = @()
	
	        # Get the nodes in the cluster via WMI.
	        $clNodes = Get-WmiObject -Namespace root\mscluster -ComputerName $cluster.Name -Class mscluster_node | Select-Object Name
	        
	        # For each returned node from the WMI query.
	
	        foreach ($node in $clNodes)
	        {
	            if ((Test-NetConnection -ComputerName $computer -Port 3389 -InformationLevel Quiet -WarningAction SilentlyContinue) -eq $true)
	            {
	                $clServerConfigResult += Get-DbaComputerSystem -ComputerName $node.Name
	                #$clServerDiskConfig += Get-DbaDiskSpace -ComputerName $server
	                #$clServerOS += Get-DbaOperatingSystem -ComputerName $server | select ComputerName,Manufacturer,Organization,Architecture,Version,Build,InstallDate,LastBootTime,LocalDateTime,
	                #                                                             PowerShellVersion,TimeZone,TotalVisibleMemory,FreePhysicalMemory,TotalVirtualMemory,FreeVirtualMemory,Language
	            }
	            else
	            {
	                Write-Host $node.Name + " is offline."
	            }
	        }
	
	        # Set the Worksheet name. We will use one worksheet per cluster.
	
	        $clServerConfigWorksheet = $cluster.Name
	
	        # Set the table name for the Worksheet.
	
	        $clServerConfigTableName = $cluster.Name
	
	        $clServerConfigResult | Export-Excel -Path $Path -AutoSize -WorksheetName $clServerConfigWorksheet -FreezeTopRow -TableName $clServerConfigTableName
	    }
	       
	}
	
	
}
#endregion Source: Get-ClusterNodes.ps1

#region Source: CombineSQLReportTools\Functions\Get-ClusterResource.ps1
function Invoke-Get-ClusterResource_ps1
{
	function Get-ClusterResource
	{
	  param($cluster)
	    gwmi -ComputerName $cluster -Authentication PacketPrivacy -Namespace "root\mscluster" -Class MSCluster_Resource | add-member -pass NoteProperty Cluster $cluster | 
	    add-member -pass ScriptProperty Node `
	    { gwmi -namespace "root\mscluster" -computerName $this.Cluster -Authentication PacketPrivacy -query "ASSOCIATORS OF {MSCluster_Resource.Name='$($this.Name)'} WHERE AssocClass = MSCluster_NodeToActiveResource" | Select -ExpandProperty Name } |
	    add-member -pass ScriptProperty Group `
	    { gwmi -ComputerName $this.Cluster -Authentication PacketPrivacy -Namespace "root\mscluster" -query "ASSOCIATORS OF {MSCluster_Resource.Name='$($this.Name)'} WHERE AssocClass = MSCluster_ResourceGroupToResource" | Select -ExpandProperty Name }
	}
}
#endregion Source: Get-ClusterResource.ps1

#region Source: CombineSQLReportTools\Functions\Get-InstalledSQLServices.ps1
function Invoke-Get-InstalledSQLServices_ps1
{
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/7/2018 10:46 AM
		 Created by:   	Andy DeAngelis
		 Organization: 	
		 Filename:     	Get-InstalledSQLServices
		===========================================================================
		.DESCRIPTION
			Function to return a list of all SQL services installed on a computer.
	
		#````Note: Powershellv3 or higher and dbatools is needed.
	#>
	
	function Get-InstalledSQLServices
	{
		
		# This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
		Param (
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			[string[]]$ComputerNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
		)
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		$installedSQLScript = {
			
			Param ($computer,
				$parent,
				$domainCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			try
			{
				if (-not $domainCred)
				{
					$services = Get-DbaSQLService -ComputerName $computer
					$services
				}
				else
				{
					$services = Get-DbaSQLService -ComputerName $computer -Credential $domainCred
					$services
				}
			}
			catch
			{
				Write-Host "No SQL Services installed."
			}
			
		} # End script block
		
		
		$Throttle = 8
		$sqlConfigInitialSessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
		$sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $Throttle, $sqlConfigInitialSessionState, $Host)
		$sqlConfigRunspacePool.Open()
		$sqlConfigJobs = @()
		
		foreach ($computer in $ComputerNames)
		{
			$sqlConfigJob = [powershell]::Create().AddScript($installedSQLScript).AddArgument($computer).AddArgument($parent).AddArgument($domainCredential)
			$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
			$sqlConfigJobs += New-Object PSObject -Property @{
				Pipe    = $sqlConfigJob
				Result  = $sqlConfigJob.BeginInvoke()
			}
		}
		
		Write-Host "Getting installed SQL services..." -NoNewline -ForegroundColor Green
		
		Do
		{
			Write-Host "." -NoNewline -ForegroundColor Green
			Start-Sleep -Milliseconds 200
		}
		while ($sqlConfigJobs.Result.IsCompleted -contains $false)
		
		$installedSQLSvcConfig = @()
		
		ForEach ($sqlConfigJob in $sqlConfigJobs)
		{
			$installedSQLSvcConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
		}
		
		Write-Host "All jobs completed!" -ForegroundColor Green
		
		$sqlConfigRunspacePool.Close()
		$sqlConfigRunspacePool.Dispose()
		
		return $installedSQLSvcConfig
		
	}
	
	
}
#endregion Source: Get-InstalledSQLServices.ps1

#region Source: CombineSQLReportTools\Functions\Get-IsAlive.ps1
function Invoke-Get-IsAlive_ps1
{
	# Function to determine of a server is alive by testing network connection.
	
	function Get-IsAlive 
	{ 
	  Param(
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			[string[]]$ComputerNames
		)
		
	  $aliveScript = {
			
			Param ($computer,
				$port)
			
	    # Let's hide the progress bars by setting the global variable $ProgressPreference for the session.
	
	    # $ProgressPreference = 'SilentlyContinue'
		
	     function Test-TCPport 
	     {
	        Param([parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$ComputerName,
					[parameter(Mandatory = $true, ValueFromPipeline = $True)]
					$TCPport
	        )
	
	        $requestCallback = $state = $null
	        $client = New-Object System.Net.Sockets.TcpClient
	        $beginConnect = $client.BeginConnect($ComputerName,$TCPport,$requestCallback,$state)
	        Start-Sleep -Milliseconds 2000
	        if ($client.Connected) 
	        {
	            $open = $true
	        } 
	        else
	        {
	            $open = $false            
	        }
	
	        $client.Close()
	        
	        [pscustomobject]@{hostname=$ComputerName;port=$TCPport;open=$open}
	     }
			
			$status = Test-TCPport -ComputerName $computer -TCPport $port
			
			if ($status.open)
			{
				$computer
			}
			
		}
		
		$Throttle = 20
	  $isAliveInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $isAliveRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$isAliveInitialSessionState,$Host)
	  $isAliveRunspacePool.Open()
	  $isAliveJobs = @()
	
	  foreach ($computer in $ComputerNames)
	  {
		$port = 5985
	    $isAliveJob = [powershell]::Create().AddScript($aliveScript).AddArgument($computer).AddArgument($port)
	    $isAliveJob.RunspacePool = $isAliveRunspacePool
	    $isAliveJobs += New-Object PSObject -Property @{
	      Pipe = $isAliveJob
	      Result = $isAliveJob.BeginInvoke()
	    } 
	  }
	
	  Write-Host "Checking if servers are alive..." -NoNewline -ForegroundColor Green
	
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 500
	  } while ($isAliveJobs.Result.IsCompleted -contains $false)
	
	  $aliveServers = @()
	
	  ForEach ($isAliveJob in $isAliveJobs) 
	  {     
	    $aliveServers += $isAliveJob.Pipe.EndInvoke($isAliveJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	  $isAliveRunspacePool.Close()
	  $isAliveRunspacePool.Dispose()
	
	 
	
	  return $aliveServers
	} 
}
#endregion Source: Get-IsAlive.ps1

#region Source: CombineSQLReportTools\Functions\Get-IsClustered.ps1
function Invoke-Get-IsClustered_ps1
{
	# Function to determine of a node is part of a cluster by querying WMI.
	# While it's true that using the FailOver cluster PS module would be leaps and bounds easier, you may end up running this from a server that does not have it.
	# As such, we will be using WMI to grab initial cluster data.
	
	function Get-IsClustered 
	{ 
	  Param(
	    [parameter(Mandatory=$true,ValueFromPipeline=$True)]
		[string[]]$ComputerName,
		[parameter(Mandatory = $false, ValueFromPipeline = $True)]
		$domainCredential
		)
		
		if ($domainCredential)
		{
			if ((Get-WMIObject -Credential $domainCredential -Namespace root\mscluster -ComputerName $ComputerName -Class MSCluster_cluster -ErrorAction SilentlyContinue) -ne $null)
			{
				return $true
			}
			else
			{
				return $false
			}
		}
		else
		{
			if ((Get-WMIObject -Namespace root\mscluster -ComputerName $ComputerName -Class MSCluster_cluster -ErrorAction SilentlyContinue) -ne $null)
			{
				return $true
			}
			else
			{
				return $false
			}
		}
	} 
}
#endregion Source: Get-IsClustered.ps1

#region Source: CombineSQLReportTools\Functions\Get-RebootHistory.ps1
function Invoke-Get-RebootHistory_ps1
{
	Function Get-RebootHistory {  
	    <# 
	        .SYNOPSIS 
	            Retrieves historical information about shutdown/restart events from one or more remote computers. 
	     
	        .DESCRIPTION 
	            The Get-RebootHistory function uses Windows Management Instrumentation (WMI) to retrieve information about all shutdown events from a remote computer.   
	             
	            Using this function, you can analyze shutdown events across a large number of computers to determine how frequently shutdown/restarts are occurring, whether unexpected shutdowns are occurring and quickly identify the source of the last clean shutdown/restart. 
	             
	            Data returned includes date/time information for all available boot history events (e.g. restarts, shutdowns, unexpected shutdowns, etc.), date/time information for unexpected reboots and detailed information about the last clean shutdown including date/time, type, initiating user, initiating process and reason.      
	             
	            Because Get-RebootHistory uses WMI to obtain shutdown event history from the system event log, it is fully supported against both legacy and current versions of Windows including legacy versions that do not support filtering of event logs through standard methods.  
	         
	        .PARAMETER ComputerName 
	            Accepts a single computer name or an array of computer names separated by commas (e.g. "prod-web01","prod-web02").  
	 
	            This is an optional parameter, the default value is the local computer ($Env:ComputerName). 
	         
	        .PARAMETER Credential 
	            Accepts a standard credential object. 
	             
	            This is an optional parameter and is only necessary when the running user does not have access to the remote computer(s). 
	 
	        .EXAMPLE 
	            .\Get-RebootHistory -ComputerName prod-web01,prod-web02 -Credential (Get-Credential) 
	         
	            Get boot history for multiple remote computers with alternate credentials.  
	         
	        .EXAMPLE 
	            .\Get-RebootHistory -ComputerName prod-web01,prod-web02 -Credential (Get-Credential) | ? { $_.PercentDirty -ge 30 } 
	         
	            Get a list of computers experiencing a high percentage of unexpected shutdown events. 
	         
	        .EXAMPLE  
	            .\Get-RebootHistory -ComputerName prod-web01,prod-web02 -Credential (Get-Credential) | ? { $_.RecentShutdowns -ge 3 }  
	         
	            Return information about servers that have been experiencing frequent shutdown/reboot events over the last 30 days. 
	         
	        .OUTPUTS 
	            System.Management.Automation.PSCustomObject  
	             
	            Return object includes the following properties:  
	             
	                Computer                 
	                BootHistory                : Array of System.DateTime objects for all recorded instances of the system booting (clean or otherwise). 
	                RecentShutdowns            : The number of shutdown/restart events in the last 30 days. 
	                UnexpectedShutdowns        : Array of System.DateTime objects for all recorded unexpected shutdown events. 
	                RecentUnexpected        : The number of unexpected shutdown events in the last 30 days. 
	                PercentDirty            : The percentage of shutdown events that were unexpected (UnexpectedShutdowns/BootHistory). 
	                LastShutdown            : System.DateTime object of the last clean shutdown event. 
	                LastShutdownType        : Type of the last clean shutdown event (Restart | Shutdown). 
	                LastShutdownUser        : The user who initiated the last clean shutdown event. 
	                LastShutdownProcess        : The process that initiated the last clean shutdown event. 
	                LastShutdownReason        : If available, the reason code and comments for the last clean shutdown event. 
	                 
	        .NOTES 
	            Author            : Eric Westfall 
	            Email            : eawestfall@gmail.com 
	            Script Version    : 1.1 
	            Revision Date    : 11/26/2014 
	    #> 
	     
	    Param ( 
	        [Parameter(Mandatory = $False, Position = 0, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)] 
	        [Alias("CN","Computer")] 
	        [Array]$ComputerName = $Env:ComputerName, 
	 
	        [Parameter(Mandatory = $False, Position = 1, ValueFromPipeline = $False)] 
	        [Alias("Cred")] 
	        [ValidateNotNull()] 
	        [System.Management.Automation.PSCredential]$Credential = [System.Management.Automation.PSCredential]::Empty 
	    ) 
	     
	    Begin { 
	        $i = 0 
	        $RecentShutdowns = 0 
	        $RecentUnexpected = 0 
	         
	        $BootHistory = @() 
	        $ShutdownDetail = @() 
	        $UnexpectedShutdowns = @()  
	         
	        # Store original credential, if we attempt to make a local connection we need to  
	        # temporarily empty out the credential object. 
	        $Original_Credential = $Credential 
	         
	        # Select properties defined to ensure proper display order. 
	        $BootInformation = @( 
	            "Computer" 
	            "BootHistory" 
	            "RecentShutdowns" 
	            "UnexpectedShutdowns" 
	            "RecentUnexpected" 
	            "PercentDirty" 
	            "LastShutdown" 
	            "LastShutdownType" 
	            "LastShutdownUser" 
	            "LastShutdownProcess" 
	            "LastShutdownReason" 
	        ) 
	         
	        # Arguments to be passed to our WMI call.  
	        $Params = @{ 
	            ErrorAction        = 'Stop' 
	            ComputerName    = $Computer 
	            Credential        = $Credential 
	            Class            = 'Win32_NTLogEvent' 
	            Filter            = "LogFile = 'System' and EventCode = 6009 or EventCode = 6008 or EventCode = 1074" 
	        } 
	    } 
	 
	    Process { 
	        ForEach ($Computer In $ComputerName) { 
	            $Params.ComputerName = $Computer 
	             
	            # You can't use credentials when connecting to the local machine so temporarily empty out the credential object. 
	            If ($Computer -eq $Env:ComputerName) {  
	                $Params.Credential = [System.Management.Automation.PSCredential]::Empty 
	            } 
	             
	            If ($ComputerName.Count -gt 1) {  
	                Write-Progress -Id 1 -Activity "Retrieving boot history." -Status ("Percent Complete: {0:N0}" -f $($i / $($ComputerName.Count)*100)) -PercentComplete (($i / $ComputerName.Count)*100); $i++ 
	            } Else {  
	                Write-Progress -Id 1 -Activity "Retrieving boot history." 
	            } 
	 
	            Try {  
	                $d = 0 
	                $Events = Get-WmiObject @Params 
	                 
	                ForEach ($Event In $Events) {  
	                    Write-Progress -Id 2 -ParentId 1 -Activity "Processing reboot history." -PercentComplete (($d / $Events.Count)*100); $d++ 
	                     
	                    # Record the relevant details for the shutdown event. 
	                    Switch ($Event.EventCode) {  
	                        6009 { $BootHistory += (Get-Date(([WMI]'').ConvertToDateTime($Event.TimeGenerated)) -Format g) } 
	                        6008 { $UnexpectedShutdowns += ('{0} {1}' -f ($Event.InsertionStrings[1], $Event.InsertionStrings[0])) } 
	                        1074 { $ShutdownDetail += $Event } 
	                    } 
	                } 
	                 
	                # We explicitly ignore exceptions originating from this process since some versions of Windows may store dates in invalid formats (e.g. ?11/?16/?2014) in the event log after an unexpected shutdown causing this calculation to fail. 
	                Try {  
	                    $RecentUnexpected = ($UnexpectedShutdowns | ? { ((Get-Date)-(Get-Date $_)).TotalDays -le 30 }).Count 
	                } Catch {  
	                    $RecentUnexpected = "Unable to calculate." 
	                }  
	                 
	                # Grab details about the last clean shutdown and generate our return object. 
	                $ShutdownDetail | Select -First 1 | ForEach-Object {  
	                    New-Object -TypeName PSObject -Property @{ 
	                        Computer = $Computer 
	                        BootHistory = $BootHistory  
	                        RecentUnexpected = $RecentUnexpected 
	                        LastShutdownUser = $_.InsertionStrings[6] 
	                        UnexpectedShutdowns = $UnexpectedShutdowns 
	                        LastShutdownProcess = $_.InsertionStrings[0] 
	                        PercentDirty = '{0:P0}' -f (($UnexpectedShutdowns.Count/$BootHistory.Count)) 
	                        LastShutdownType = (Get-Culture).TextInfo.ToTitleCase($_.InsertionStrings[4]) 
	                        LastShutdown = (Get-Date(([WMI]'').ConvertToDateTime($_.TimeGenerated)) -Format g) 
	                        RecentShutdowns = ($BootHistory | ? { ((Get-Date)-(Get-Date $_)).TotalDays -le 30 }).Count 
	                        LastShutdownReason = 'Reason Code: {0}, Reason: {1}' -f ($_.InsertionStrings[3], $_.InsertionStrings[2]) 
	                    } | Select $BootInformation     
	                }             
	            } Catch [System.Exception] {  
	                # We explicitly ignore exceptions originating from Get-Date since some versions of Windows may store dates in invalid formats in the event log after an unexpected shutdown. 
	                If ($_.CategoryInfo.Activity -ne 'Get-Date') {  
	                    Write-Warning ("Unable to retrieve boot history for {0}. `nError Details: {1}" -f ($Computer, $_)) 
	                } 
	            } 
	             
	            # Reset credential object since we may have temporarily overwrote it to deal with local connections. 
	            $Params.Credential = $Original_Credential 
	        } 
	    } 
	} 
	 
	Export-ModuleMember -Function Get-RebootHistory
}
#endregion Source: Get-RebootHistory.ps1

#region Source: CombineSQLReportTools\Functions\Get-ServerConfig.ps1
function Invoke-Get-ServerConfig_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-ServerConfig function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns all relevant server config data and exports that data to a spreadsheet.
	#    Usage: 
	#    Usage: 
	#           - Multiple servers can be passed to the -ComputerNames paramater.
	#           - The user running the script needs to be a local administrator on the target servers to gather WMI data.
	#           - This script also uses dbatools.
	#           - The result returned is an array of objects that can then be passed to anything (CSV, Excel, other functions, etc.)
	#    Examples:
	#               . .\Get-ServerConfig.ps1
	#
	#               Get-ServerConfig -ComputerName SERVER1,SERVER2,SERVER3
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	# Function to get Server Configuration info for all servers in the my_servers.txt file.
	# Only works for Windows.
	# At some point, add support to query for Linux as well.
	
	function Get-ServerConfig
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			$ComputerName,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	   #   [parameter(Mandatory=$true,ValueFromPipeline=$True)] $Path
	  )
	  
	  # Let's get some data. For each server in the $ComputerNames array. get target computer system information and add it to the array.
	  # Since we are using the PoshRSJobs module, we will create the script blobk below.
	
	  $getSvrConfigScript = {
	
	        Param ($server,$parent,$domainCred)
	
	        Import-module "$parent\Modules\dbatools\dbatools.psm1"
	        
	        # Ping the server to see if it is online.
	        if ($server -ne $null)
	        {
	            # Server is responding to ping, but let's make sure it's a Windows machine.              
	      
	            try
				{
					if (-not $domainCred)
					{
						$isWindows = (Get-WmiObject Win32_OperatingSystem -ComputerName $server -erroraction 'silentlycontinue').Name
					}
					else
					{
						$isWindows = (Get-WmiObject Win32_OperatingSystem -ComputerName $server -Credential $domainCred -erroraction 'silentlycontinue').Name
					}
				}
				catch
				{
					Write-Host "Unable to connect to $server. Is this a Windows OS?" -ForegroundColor Red
				}
				if ($isWindows)
	            {
					
					if (-not $domainCred)
					{
						$ServerConfigObject = Get-DbaComputerSystem -ComputerName $server -WarningAction SilentlyContinue
						$ServerOSObject = Get-DbaOperatingSystem -ComputerName $server -WarningAction SilentlyContinue
					}
					else
					{
						$ServerConfigObject = Get-DbaComputerSystem -ComputerName $server -Credential $domainCred -WarningAction SilentlyContinue
						$ServerOSObject = Get-DbaOperatingSystem -ComputerName $server -Credential $domainCred -WarningAction SilentlyContinue
					}
					
	            
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name TotalVisibleMemory -Value $ServerOSObject.TotalVisibleMemory
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name FreePhysicalMemory -Value $ServerOSObject.FreePhysicalMemory
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name TotalVirtualMemory -Value $ServerOSObject.TotalVirtual
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name FreeVirtualMemory -Value $ServerOSObject.FreeVirtualMemory
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name OperatingSystem -Value (Get-WMIObject win32_OperatingSystem -ComputerName $server).Caption
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name Version -Value (Get-WMIObject win32_OperatingSystem -ComputerName $server).Version
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name ServicePackMajorVersion -Value (Get-WMIObject win32_OperatingSystem -ComputerName $server).ServicePackMajorVersion
	            $ServerConfigObject | Add-Member -MemberType NoteProperty -Name ServicePackMinorVersion -Value (Get-WMIObject win32_OperatingSystem -ComputerName $server).ServicePackMinorVersion
	            
	            if ((Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster -ErrorAction SilentlyContinue) -ne $null)
	            {
	                $ServerConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'Yes'
	                $ServerConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value (Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster).Name
	            }
	            else
	            {
	                $ServerConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'No'
	                $ServerConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value 'NOT CLUSTERED'
	            }
	            
	            $ServerConfigObject.PSObject.Properties.Remove('SystemSkuNumber')
	            $ServerConfigObject.PSObject.Properties.Remove('IsDaylightSavingsTime')
	            $ServerConfigObject.PSObject.Properties.Remove('DaylightInEffect')
	            $ServerConfigObject.PSObject.Properties.Remove('AdminPasswordStatus')
	            $ServerConfigObject.PSObject.Properties.Remove('TotalPhysicalMemory')
	            
	            # $Using:ServerConfigResult += $ServerConfigObject
	
	            $ServerConfigObject  
	                
	              }           
	        }
	        else
	        {
	            Write-Host "Server name is null."
	        }
	       
	    }
	
	  $getDiskConfigScript = {
	
	        Param ($server,$parent,$domainCred)
	
	        Import-module "$parent\Modules\dbatools\dbatools.psm1"
	
	        if ($server -ne $null)
	        {
	            # Server is responding to ping, but let's make sure it's a Windows machine.              
	      
	            try
				{
					if (-not $domainCred)
					{
						$isWindows = (Get-WmiObject Win32_OperatingSystem -ComputerName $server -erroraction 'silentlycontinue').Name
					}
					else
					{
						$isWindows = (Get-WmiObject Win32_OperatingSystem -ComputerName $server -Credential $domainCred -erroraction 'silentlycontinue').Name
					}
				}
				catch
				{
					Write-Host "Unable to connect to $server. Is this a Windows OS?" -ForegroundColor Red
				}
				if ($isWindows)
	            {
					
					if (-not $domainCred)
					{
						$ServerDiskConfigObject = Get-DbaDiskSpace -ComputerName $server | Select ComputerName, Server, Name, Label, Capacity,
																								  Free, PercentFree, BlockSize, FileSystem, Type,
																								  DriveType, SizeInGB, FreeInGB, SizeInTB, FreeInTB
						
						if ((Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster -ErrorAction SilentlyContinue) -ne $null)
						{
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'Yes'
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value (Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster).Name
						}
						else
						{
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'No'
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value 'NOT CLUSTERED'
						}
					}
					else
					{
						$ServerDiskConfigObject = Get-DbaDiskSpace -ComputerName $server -Credential $domainCred | Select ComputerName, Server, Name, Label, Capacity,
																														  Free, PercentFree, BlockSize, FileSystem, Type,
																														  DriveType, SizeInGB, FreeInGB, SizeInTB, FreeInTB
						
						if ((Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster -Credential $domainCred -ErrorAction SilentlyContinue) -ne $null)
						{
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'Yes'
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value (Get-WMIObject -Namespace root\mscluster -ComputerName $server -Class MSCluster_cluster).Name
						}
						else
						{
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name IsClustered -Value 'No'
							$ServerDiskConfigObject | Add-Member -MemberType NoteProperty -Name ClusterName -Value 'NOT CLUSTERED'
						}
					}
					
					$ServerDiskConfigObject
	                
	            }
	        }
	        else
	        {
	            Write-Host "Server name is null."
	        }
	       
	    }
	
	  $parent = Split-Path -Path $PSScriptRoot -Parent    
	  
	  # For each server, start a separate runspace job.
	
	  $Throttle = 8
	  $svrConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $svrConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$svrConfigInitialSessionState,$Host)
	  $svrConfigRunspacePool.Open()
	  $svrConfigJobs = @()
	
	  foreach ($server in $ComputerName)
	  {
	    $svrConfigJob = [powershell]::Create().AddScript($getSvrConfigScript).AddArgument($server).AddArgument($parent).AddArgument($domainCredential)
	    $svrConfigJob.RunspacePool = $svrConfigRunspacePool
	    $svrConfigJobs += New-Object PSObject -Property @{
	      Pipe = $svrConfigJob
	      Result = $svrConfigJob.BeginInvoke()
	    } 
	  }
	
	  $svrDiskConfiginitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $svrDiskConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$svrDiskConfigInitialSessionState,$Host)
	  $svrDiskConfigRunspacePool.Open()
	  $svrDiskConfigJobs = @()
	
	  foreach ($server in $ComputerName)
	  {
	    $svrDiskConfigJob = [powershell]::Create().AddScript($getDiskConfigScript).AddArgument($server).AddArgument($parent).AddArgument($domainCredential)
	    $svrDiskConfigJob.RunspacePool = $svrDiskConfigRunspacePool
	    $svrDiskConfigJobs += New-Object PSObject -Property @{
	      Pipe = $svrDiskConfigJob
	      Result = $svrDiskConfigJob.BeginInvoke()
	    } 
	  }
	  
	  $svrConfigResults = @()
	  $svrDiskConfigResults = @()
	
	  Write-Host "Getting server configuration..." -NoNewline -ForegroundColor Green
	
	  Do
	  {
		Write-Host "." -NoNewline -ForegroundColor Green
		Start-Sleep -Milliseconds 200
	  } while (($svrConfigJobs.Result.IsCompleted -contains $false) -or ($svrDiskConfigJobs.Result.IsCompleted -contains $false))
	
	  ForEach ($svrConfigJob in $svrConfigJobs) 
	  {       
	    $svrConfigResults += $svrConfigJob.Pipe.EndInvoke($svrConfigJob.Result)
	  }
	
	  ForEach ($svrDiskConfigJob in $svrDiskConfigJobs) 
	  {       
	    $svrDiskConfigResults += $svrDiskConfigJob.Pipe.EndInvoke($svrDiskConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	# $Results | Out-GridView
	  $svrConfigRunspacePool.Close()
	  $svrConfigRunspacePool.Dispose()
	
	  $svrDiskConfigRunspacePool.Close()
	  $svrDiskConfigRunspacePool.Dispose()
	 
	  return $svrConfigResults,$svrDiskConfigResults
	  
	}
}
#endregion Source: Get-ServerConfig.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLAGConfig.ps1
function Invoke-Get-SQLAGConfig_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-SQLAGConfig function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns the configuration of all availability groups in a list of SQL instances.
	#    Usage: 
	#           - Source the function and pass the instance name as a parameter.
	#           - This script also uses dbatools PowerShell module.
	#
	#    Examples:
	#               . .\Get-SQLAGConfig
	#
	#               Get-SQLAGConfig -instanceNames "SERVER\Instance01","SERVER02\Instance02" -SQLCredential (Get-Credential)
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLAGConfig
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$instanceNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$SQLCredential,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	  )
	
	  $parent = Split-Path -Path $PSScriptRoot -Parent
		
		$agConfigScript = {
			
			Param ($instance,
				$parent,
				$sqlCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
				
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			# If the logged on user credentials fail, test using SQL creds.
			
			if (-not $testDBAConnectionSession)
			{
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL or session credentials." -ForegroundColor Red
				}
			}
			
			if ($testDBAConnectionSession -or $testDBAConnectionSQL)
			{	
				if ($sqlObj.IsHaDREnabled)
				{
					# Depending on what credentials successfully connected, we'll pull the AG configuration data.'
					
					$agConfigResult = @()
					
					if ($testDBAConnectionSession)
					{
						$ags = $sqlObj.AvailabilityGroups
						foreach ($ag in $ags)
						{
							$agConfigObject = { $ag }.Invoke()
							
							$agConfigObject | Add-Member -MemberType NoteProperty -Name ComputerName -value $sqlObj.NetName
							$agConfigObject | Add-Member -MemberType NoteProperty -Name InstanceName -value $sqlObj.ServiceName
							$agConfigObject | Add-Member -MemberType NoteProperty -Name SqlInstance -value $sqlObj.DomainInstanceName
							
							$agConfigResult += $agConfigObject | select * -ExcludeProperty ClusterType, Urn, ExecutionManager, UserData, Properties
						}
					}
					elseif ($testDBAConnectionSQL -and (-not $testDBAConnectionSession))
					{
						$ags = $sqlObj.AvailabilityGroups
						foreach ($ag in $ags)
						{
							$agConfigObject = { $ag }.Invoke()
							
							$agConfigObject | Add-Member -MemberType NoteProperty -Name ComputerName -value $sqlObj.NetName
							$agConfigObject | Add-Member -MemberType NoteProperty -Name InstanceName -value $sqlObj.ServiceName
							$agConfigObject | Add-Member -MemberType NoteProperty -Name SqlInstance -value $sqlObj.DomainInstanceName
							
							$agConfigResult += $agConfigObject | select * -ExcludeProperty ClusterType, Urn, ExecutionManager, UserData, Properties
						}
					}
					else
					{
						$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
						$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
						Write-host $testConnectMsg -foregroundcolor "magenta"
						# $testConnectMsg | Out-File -FilePath $failedConnections -Append
					}
					
					Clear-Variable sqlObj
					
					$agConfigResult
				}
			}
		} # End script block
		
		$agConfigScriptDomain = {
			
			Param ($instance,
				$parent,
				$sqlCred,
				$domainCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			if (-not $testDBAConnectionSession)
			{
				# If the logged on user credentials fail, test using SQL creds.
				
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
				}
			}
			
			if ((-not $testDBAConnectionSession) -and (-not $testDBAConnectionSQL))
			{
				# Also, we're going to test domain credentials, if they were specified.
				
				try
				{
					# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
					$user = $domainCred.UserName.Split("\")
					$username = "$($user[1])@$($user[0])"
					
					$sqlObj.ConnectionContext.LoginSecure = $true
					$sqlObj.ConnectionContext.ConnectAsUser = $true
					$sqlObj.ConnectionContext.ConnectAsUserName = $username
					$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCred.GetNetworkCredential().Password
					
					$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using provided Domain credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
				}
			}
			
			if ($sqlObj.IsHaDREnabled)
			{
				$agConfigResult = @()
				
				# Depending on what credentials successfully connected, we'll pull the SP configure data.'
				
				if ($testDBAConnectionSession -or $testDBAConnectionSQL -or $testDBAConnectionDomain)
				{
					$ags = $sqlObj.AvailabilityGroups
					
					foreach ($ag in $ags)
					{
						$agConfigObject = { $ag }.Invoke()
						
						$agConfigObject | Add-Member -MemberType NoteProperty -Name ComputerName -value $sqlObj.NetName
						$agConfigObject | Add-Member -MemberType NoteProperty -Name InstanceName -value $sqlObj.ServiceName
						$agConfigObject | Add-Member -MemberType NoteProperty -Name SqlInstance -value $sqlObj.DomainInstanceName
						
						$agConfigResult += $agConfigObject | select * -ExcludeProperty ClusterType, Urn, ExecutionManager, UserData, Properties
					}
				}
				else
				{
					$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
					$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
					Write-host $testConnectMsg -foregroundcolor "magenta"
					# $testConnectMsg | Out-File -FilePath $failedConnections -Append
				}
				
			}
			
			Clear-Variable sqlObj
			
			$agConfigResult
			
		} # End script block
	
	  
	  $Throttle = 8
	  $sqlConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$sqlConfigInitialSessionState,$Host)
	  $sqlConfigRunspacePool.Open()
	  $sqlConfigJobs = @()
	
	  foreach ($instance in $instanceNames)
	  {
			if (-not $domainCredential)
			{
				$sqlConfigJob = [powershell]::Create().AddScript($agConfigScript).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	 = $sqlConfigJob
					Result   = $sqlConfigJob.BeginInvoke()
				}
			}
			else
			{
				$sqlConfigJob = [powershell]::Create().AddScript($agConfigScriptDomain).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential).AddArgument($domainCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	  = $sqlConfigJob
					Result    = $sqlConfigJob.BeginInvoke()
				}
			}
		}
		
		Write-Host "Getting Availability Group Configuration..." -NoNewline -ForegroundColor Green
	
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 200
	  } while ($sqlConfigJobs.Result.IsCompleted -contains $false)
	
	  $agsqlConfig = @()
	
	  ForEach ($sqlConfigJob in $sqlConfigJobs) 
	  {     
	    $agsqlConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	  $sqlConfigRunspacePool.Close()
	  $sqlConfigRunspacePool.Dispose()
	
	  return $agsqlConfig  
	  
	}
}
#endregion Source: Get-SQLAGConfig.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLBackupHistory.ps1
function Invoke-Get-SQLBackupHistory_ps1
{
	<#	
		.NOTES
		===========================================================================
		 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2018 v5.5.150
		 Created on:   	5/22/2018 1:48 PM
		 Created by:   	Andy DeAngelis
		 Organization: 	
		 Filename: Get-SQLBackupHistory.ps1     	
		===========================================================================
		.DESCRIPTION
			Returns the backup history of each SQL instance specified.
	#>
	
	function Get-SQLBackupHistory
	{
		
		# This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
		Param (
			[parameter(Mandatory = $true, ValueFromPipeline = $True)]
			[string[]]$instanceNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$SQLCredential,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
		)
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		Write-Host "Getting SQL Backup History..." -NoNewline -ForegroundColor Green
		
		$SQLBackupHostoryScript = {
			
			Param ($instance,
				$parent,
				$sqlCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
				
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			# If the logged on user credentials fail, test using SQL creds.
			
			if (-not $testDBAConnectionSession)
			{
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL or session credentials." -ForegroundColor Red
				}
			}
			
			if ($testDBAConnectionSession)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ($testDBAConnectionSQL)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			else
			{
				$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
				$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
				Write-host $testConnectMsg -foregroundcolor "magenta"
				# $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$sqlConfig | Add-Member -MemberType NoteProperty -Name "Instance Name" -Value $instance
			
			$sqlConfig
		} # End script block
		
		$SQLBackupHistoryScriptDomain = {
			
			Param ($instance,
				$parent,
				$sqlCred,
				$domainCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			if (-not $testDBAConnectionSession)
			{
				# If the logged on user credentials fail, test using SQL creds.
				
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
				}
			}
			
			if ((-not $testDBAConnectionSession) -and (-not $testDBAConnectionSQL))
			{
				# Also, we're going to test domain credentials, if they were specified.
				
				try
				{
					# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
					$user = $domainCred.UserName.Split("\")
					$username = "$($user[1])@$($user[0])"
					
					$sqlObj.ConnectionContext.LoginSecure = $true
					$sqlObj.ConnectionContext.ConnectAsUser = $true
					$sqlObj.ConnectionContext.ConnectAsUserName = $username
					$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCred.GetNetworkCredential().Password
					
					$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using provided Domain credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
				}
			}
			
			# Depending on what credentials successfully connected, we'll pull the SP configure data.'
			
			if ($testDBAConnectionSession)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ($testDBAConnectionSQL -and (-not $testDBAConnectionDomain))
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ((-not $testDBAConnectionSQL) -and $testDBAConnectionDomain)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ($testDBAConnectionSQL -and $testDBAConnectionDomain)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			else
			{
				$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
				$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
				Write-host $testConnectMsg -foregroundcolor "magenta"
				# $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$sqlConfig | Add-Member -MemberType NoteProperty -Name "Instance Name" -Value $instance
			
			$sqlConfig
			
		} # End script block
		
		
		
		
		$Throttle = 8
		$sqlConfigInitialSessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
		$sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $Throttle, $sqlConfigInitialSessionState, $Host)
		$sqlConfigRunspacePool.Open()
		$sqlConfigJobs = @()
		
		foreach ($instance in $instanceNames)
		{
			if (-not $domainCredential)
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScript).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	 = $sqlConfigJob
					Result   = $sqlConfigJob.BeginInvoke()
				}
			}
			else
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScriptDomain).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential).AddArgument($domainCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	  = $sqlConfigJob
					Result    = $sqlConfigJob.BeginInvoke()
				}
			}
		}
		
		Do
		{
			Write-Host "." -NoNewline -ForegroundColor Green
			Start-Sleep -Milliseconds 200
		}
		while ($sqlConfigJobs.Result.IsCompleted -contains $false)
		
		$sqlSPConfig = @()
		
		ForEach ($sqlConfigJob in $sqlConfigJobs)
		{
			$sqlSPConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
		}
		
		Write-Host "All jobs completed!" -ForegroundColor Green
		
		$sqlConfigRunspacePool.Close()
		$sqlConfigRunspacePool.Dispose()
		
		return $sqlSPConfig
		
	}
}
#endregion Source: Get-SQLBackupHistory.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLConfig.ps1
function Invoke-Get-SQLConfig_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-SQLConfig function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns the running configuration of a SQL Instance.
	#    Usage: 
	#           - Source the function and pass the instance name as a parameter.
	#           - This script also uses dbatools PowerShell module.
	#
	#    Examples:
	#               . .\Get-SQLConfig.ps1
	#
	#               Get-SQLConfig -instanceName SERVER\Instance
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLConfig
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$instanceNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$SQLCredential,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	  )
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		Write-Host "Getting SQL Configuration..." -NoNewline -ForegroundColor Green
	
		$SQLConfigScript = {
	
	        Param ($instance,$parent,$sqlCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
	        try
	        {
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
				
	        }
	        catch
	        {
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow			
	        }
			
			# If the logged on user credentials fail, test using SQL creds.
			
	        if (-not $testDBAConnectionSession)
	        {     
	            try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
	            }
	            catch
	            {
	                Write-Host "No connection could be made to $instance using SQL or session credentials." -ForegroundColor Red
				}
			}
			
			if ($testDBAConnectionSession)
	        {
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
	        }
	        elseif ($testDBAConnectionSQL)
	        {
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
	        else
	        {
	            $errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
	            $testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
	            Write-host $testConnectMsg -foregroundcolor "magenta"
	            # $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$sqlConfig | Add-Member -MemberType NoteProperty -Name "Instance Name" -Value $instance
			
			$sqlConfig
		} # End script block
		
		$SQLConfigScriptDomain = {
	
	        Param ($instance,$parent,$sqlCred,$domainCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
	        try
	        {
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green			
	        }
	        catch
	        {
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
	        }
			
			if (-not $testDBAConnectionSession)
			{
				# If the logged on user credentials fail, test using SQL creds.
				
	            try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green				
	            }
	            catch
	            {
					Write-Host "No connection could be made to $instance using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
				}
			}
			
			if ((-not $testDBAConnectionSession) -and (-not $testDBAConnectionSQL))
			{
				# Also, we're going to test domain credentials, if they were specified.
				
				try
				{
					# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
					$user = $domainCred.UserName.Split("\")
					$username = "$($user[1])@$($user[0])"
					
					$sqlObj.ConnectionContext.LoginSecure = $true
					$sqlObj.ConnectionContext.ConnectAsUser = $true
					$sqlObj.ConnectionContext.ConnectAsUserName = $username
					$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCred.GetNetworkCredential().Password
					
					$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using provided Domain credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
				}
			}
			
			# Depending on what credentials successfully connected, we'll pull the SP configure data.'
			
			if ($testDBAConnectionSession)
	        {
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
	        }
	        elseif ($testDBAConnectionSQL -and (-not $testDBAConnectionDomain))
	        {
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ((-not $testDBAConnectionSQL) -and $testDBAConnectionDomain)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			elseif ($testDBAConnectionSQL -and $testDBAConnectionDomain)
			{
				$sqlConfig = $sqlObj.ConnectionContext.ExecuteWithResults("SELECT name,description,value,value_in_use,minimum,maximum,is_dynamic,is_advanced FROM sys.configurations") | select -ExpandProperty Tables
			}
			else
			{
				$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
				$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
				Write-host $testConnectMsg -foregroundcolor "magenta"
				# $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$sqlConfig | Add-Member -MemberType NoteProperty -Name "Instance Name" -Value $instance
			
			$sqlConfig
			
		} # End script block
		
	
	
	  
	  $Throttle = 8
	  $sqlConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$sqlConfigInitialSessionState,$Host)
	  $sqlConfigRunspacePool.Open()
	  $sqlConfigJobs = @()
	
	  foreach ($instance in $instanceNames)
		{
			if (-not $domainCredential)
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScript).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe    = $sqlConfigJob
					Result  = $sqlConfigJob.BeginInvoke()
				}
			}
			else
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScriptDomain).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential).AddArgument($domainCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	 = $sqlConfigJob
					Result   = $sqlConfigJob.BeginInvoke()
				}
			}
		}
		
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 200
	  } while ($sqlConfigJobs.Result.IsCompleted -contains $false)
	
	  $sqlSPConfig = @()
	
	  ForEach ($sqlConfigJob in $sqlConfigJobs) 
	  {     
	    $sqlSPConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	  $sqlConfigRunspacePool.Close()
	  $sqlConfigRunspacePool.Dispose()
	
	  return $sqlSPConfig  
	  
	}
}
#endregion Source: Get-SQLConfig.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLConfig.TempPoint.ps1
function Invoke-Get-SQLConfig_TempPoint_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-SQLConfig function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns the running configuration of a SQL Instance.
	#    Usage: 
	#           - Source the function and pass the instance name as a parameter.
	#           - This script also uses dbatools PowerShell module.
	#
	#    Examples:
	#               . .\Get-SQLConfig.ps1
	#
	#               Get-SQLConfig -instanceName SERVER\Instance
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLConfig
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$instanceNames,
	      [parameter(Mandatory=$false,ValueFromPipeline=$True)] $SQLCredential
	  )
	
	  $parent = Split-Path -Path $PSScriptRoot -Parent
	
	  $SQLConfigScript = {
	
	        Param ($instance,$parent,$sqlCred)
	
	        Import-module "$parent\Modules\dbatools\dbatools.psm1"
	
	        
	      try
	        {
	            $testDBAConnectionDomain = Test-DbaConnection -sqlinstance $instance
	        }
	        catch
	        {
	            Write-Host "No connection could be made using Domain credentials." -ForegroundColor Red
	        }
	              
	        if (!$testDBAConnectionDomain)
	        {     
	            try
	            {
	                $testDBAConnectionSQL = Test-DbaConnection -sqlinstance $instance -SQLCredential $sqlCred
	            }
	            catch
	            {
	                Write-Host "No connection could be made using SQL credentials." -ForegroundColor Red
	            }
	        }
	          
	        if (($testDBAConnectionDomain -and $testDBAConnectionSQL) -or ($testDBAConnectionDomain -and !($testDBAConnectionSQL)))
	        {
	            $sqlConfig = Get-DbaSpConfigure -SqlInstance $instance
	        }
	        elseif (!($testDBAConnectionDomain) -and $testDBAConnectionSQL)
	        {
	            $sqlConfig = Get-DbaSpConfigure -SqlInstance $instance -SQLCredential $sqlCred
	        }        
	        else
	        {
	            $errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
	            $testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
	            Write-host $testConnectMsg -foregroundcolor "magenta"
	            # $testConnectMsg | Out-File -FilePath $failedConnections -Append
	        }
	
	        $sqlConfig
	    } # End script block
	
	  
	  $Throttle = 8
	  $sqlConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$sqlConfigInitialSessionState,$Host)
	  $sqlConfigRunspacePool.Open()
	  $sqlConfigJobs = @()
	
	  foreach ($instance in $instanceNames)
	  {
	    $sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScript).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential)
	    $sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
	    $sqlConfigJobs += New-Object PSObject -Property @{
	      Pipe = $sqlConfigJob
	      Result = $sqlConfigJob.BeginInvoke()
	    } 
	  }
	
	  Write-Host "Getting SQL sp_configure output..." -NoNewline -ForegroundColor Green
	
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 200
	  } while ($sqlConfigJobs.Result.IsCompleted -contains $false)
	
	  $sqlSPConfig = @()
	
	  ForEach ($sqlConfigJob in $sqlConfigJobs) 
	  {     
	    $sqlSPConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	  $sqlConfigRunspacePool.Close()
	  $sqlConfigRunspacePool.Dispose()
	
	  return $sqlSPConfig  
	  
	}
}
#endregion Source: Get-SQLConfig.TempPoint.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLData.ps1
function Invoke-Get-SQLData_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-SQLData function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns all relevant SQL data by invoking the specfied SQLQueryFile paramter and the exports the returned data to a spreadsheet.
	#    Usage: 
	#           - Source the function and pass the required parameters.
	#           - Also requires a custom made or the included .sql file.
	#           - This script also uses the ImportExcel PowerShell module.
	#
	#    Examples:
	#               . .\Get-SQLData.ps1
	#
	#               Get-SQLData -instanceName SERVER\Instance -Path <PATH_TO_EXCEL_OUTPUT> -SQLQueryFile <SQL_File_to_RUN>
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLData
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)] $InstanceName,
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)] $ReportExportFileName,
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)] $SQLQueryFile,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$SQLCredential,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	  )
	
	  # Create variable that we will populate with the resultant set of data from the SQL queries.
		
		write-host "Instance name is $instanceName" -ForegroundColor Green
		
		# $sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $InstanceName
		
		if ($SQLCredential -and (-not $domainCredential))
		{
			# If the SQLCredential parameter is specified but not the domainCredential parameter.
			
			try
			{
				$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $InstanceName
				$sqlObj.ConnectionContext.LoginSecure = $false
				$sqlObj.ConnectionContext.set_Login($SQLCredential.UserName)
				$sqlObj.ConnectionContext.set_SecurePassword($SQLCredential.Password)
				
				$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $InstanceName using SQL credentials." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $InstanceName using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
			}
		}
		elseif ($domainCredential -and (-not $SQLCredential))
		{
			# If the domainCredential parameter is specified but not the SQLCredential parameter.
			
			try
			{
				$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $InstanceName
				# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
				$user = $domainCredential.UserName.Split("\")
				$username = "$($user[1])@$($user[0])"
				
				$sqlObj.ConnectionContext.LoginSecure = $true
				$sqlObj.ConnectionContext.ConnectAsUser = $true
				$sqlObj.ConnectionContext.ConnectAsUserName = $username
				$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCredential.GetNetworkCredential().Password
				
				$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $InstanceName using provided Domain credentials." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $InstanceName using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
			}
		}
		elseif ((-not $SQLCredential) -and (-not $domainCredential))
		{
			# If neither the SQLCredential parameter nor the domainCredential parameter are specified, attempt to use the running session credentials.
				
			try
			{
				$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $InstanceName
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $InstanceName using logged on session." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $InstanceName using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
		}
		elseif ($SQLCredential -and $domainCredential)
		{
			# If both SQLCredential and domainCredential parameters are set, test both connection types.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $InstanceName
			
			try
			{
				$sqlObj.ConnectionContext.LoginSecure = $false
				$sqlObj.ConnectionContext.set_Login($SQLCredential.UserName)
				$sqlObj.ConnectionContext.set_SecurePassword($SQLCredential.Password)
				
				$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $InstanceName using SQL credentials." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $InstanceName using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
			}
			
			try
			{
				# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
				$user = $domainCredential.UserName.Split("\")
				$username = "$($user[1])@$($user[0])"
				
				$sqlObj.ConnectionContext.LoginSecure = $true
				$sqlObj.ConnectionContext.ConnectAsUser = $true
				$sqlObj.ConnectionContext.ConnectAsUserName = $username
				$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCredential.GetNetworkCredential().Password
				
				$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $InstanceName using provided Domain credentials." -ForegroundColor Green
			}
			catch
			{
				Write-Host "No connection could be made to $InstanceName using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
			}
		}	
		else
		{
			Write-Host "No connection could be made using any of the supplied credentials." -ForegroundColor Red
		}
			
			
		if ($testDBAConnectionSession -or $testDBAConnectionSQL -or $testDBAConnectionDomain)
		{
			$script = Get-Content $SQLQueryFile -Raw
			$SQLDataresult = $sqlObj.ConnectionContext.ExecutewithResults($script) | select -ExpandProperty Tables
		}
		else
		{
			$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
			$testConnectMsg = "<$errorDateTime> - No connection could be made to $InstanceName. Authentication or network issue?"
			Write-host $testConnectMsg -foregroundcolor "magenta"
			# $testConnectMsg | Out-File -FilePath $failedConnections -Append
		}
		
		Clear-Variable sqlObj
		
	  # Set the worksheet name. We will have a single Excel file with one tab per Instance. Worksheet names will be labeled as SERVERNAME-INSTANCENAME.
	  
	  $SQLDataWorksheetName = $InstanceName -replace "\\","-"
	  
	  # Set the table names for the worksheet.
	  
	  $SQLDataTableName = "T" + "$SQLDataWorksheetName"
	  
	  # Possibly change to Send-SQLDatatoExcel function in the ImportExcel module.
	
	  if ($SQLDataResult -ne $null)
	  {
	    write-host "$SQLDataTableName" -ForegroundColor Cyan
	    $excel = $SQLDataResult | Export-Excel -Path $ReportExportFileName -AutoSize -WorksheetName $SQLDataWorksheetName -FreezeTopRow -TableStyle 'Medium6' -TableName $SQLDataTableName -PassThru
	    $excel.Save() ; $excel.Dispose()
	  }
	  else
	  {
	    Write-Host "No SQL Data to export." -ForegroundColor Red
		}
		
		if (Get-Variable testDBAConnectionSession -ErrorAction SilentlyContinue) { Clear-Variable testDBAConnectionSession }
		if (Get-Variable testDBAConnectionSQL -ErrorAction SilentlyContinue) { Clear-Variable testDBAConnectionSQL }
		if (Get-Variable testDBAConnectionDomain -ErrorAction SilentlyContinue) { Clear-Variable testDBAConnectionDomain }
		
	}
}
#endregion Source: Get-SQLData.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLInstances02.ps1
function Invoke-Get-SQLInstances02_ps1
{
	#######################################################################################################################################
	#
	#    Script: Get-SQLInstances02 function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         This is a replacement for the Get-SQLInstances function within the SQLPS module. The included Get-SQLInstances function is
	#         primarily for Azure SQL instances and requires the SQL Cloud Adapter, which doesn't really work. The idea is to pass a host
	#         name and return the names of all SQL instances on the host name. It's not elegant, but it works.
	#    Usage: 
	#           - Simple; source the function and pass the host name as the parameter.
	#
	#    Examples:
	#               . .\Get-SQLInstances02.ps1
	#
	#               Get-SQLInstances02 -ComputerName HOSTNAME
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLInstances02
	{
	    # This is the -Computername parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	    Param(
	        [parameter(Mandatory=$true,ValueFromPipeline=$True)] [string[]]$ComputerNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	    )
	
	    $parent = Split-Path -Path $PSScriptRoot -Parent
		
		$instanceNames = @()
		
		# Two script blocks are defined here. The first script block uses the the user credentials of the running user.
		# The second script block runs the same commands, but passes the specified domain credential object to query WMI.
		
	    $getSQLInstanceScript = {
	
	           Param($server,$parent)
	
	           $instances = @()
	
	        
	          # We need to get the correct Namespace name to query, as it changes per version of SQL Serever.
	          # For example, SQL 2014 is ROOT\Microsoft\SqlServer\ComputerManagement12 where SQL 2016 is ROOT\Microsoft\SqlServer\ComputerManagement13.
	          # Wildcards are not allowed in the Namespace parameter of the Get-WMIObject cmdlet.
	          try
	          {
	            $nameSpaceName = get-wmiobject -Namespace root\Microsoft\SQLServer -Class __Namespace -ComputerName $server -ErrorAction SilentlyContinue| Where-Object {$_.Name -like "ComputerManagement*"} | Select Name
	            $nameSpaceString = "ROOT\Microsoft\SqlServer\" + $nameSpaceName.Name
	            $instanceArray = get-wmiobject -Namespace $nameSpaceString -class ServerNetworkProtocol -ComputerName $server -ErrorAction SilentlyContinue | Where-Object {$_.ProtocolName -eq "Tcp"} | select PSComputerName,InstanceName
	          }
	          catch
	          {
	            Write-Host "No SQL instances found in WMI." -ForegroundColor Cyan
	          }       
	     
	          # Iterate through each SQL instance on the target server and return the object back to the main script.
	
	
	          foreach ($instance in $instanceArray)
	          {
	            #Check to see if the SQL service is running as the default instance.
	
	            if ($instance.InstanceName -eq "MSSQLSERVER")
	            {
	                $instanceName = $server
	            }
	            # Skip over any SQL Express instances.
	            elseif ($instance.DisplayName -match "SQLEXPRESS")
	            {
	                Write-Host "SQL Express instance...skipping..."
	                break;
	            }
	            else
	            {
	                # $instanceName = "$Computername\" + ($instance.Name).Replace("MSSQL$","")
	                $instanceName = "$server\" + $instance.InstanceName
	                # Write-Host $instanceName -ForegroundColor Green
	            }
	
	            $instances += $instanceName
	          }
	
	          $instances
			
		} # End Script block
		
		$getSQLInstanceScriptDomain = {
			
			Param ($server,
				$parent,
				$domainCred)
			
			$instances = @()
			
			
			# We need to get the correct Namespace name to query, as it changes per version of SQL Serever.
			# For example, SQL 2014 is ROOT\Microsoft\SqlServer\ComputerManagement12 where SQL 2016 is ROOT\Microsoft\SqlServer\ComputerManagement13.
			# Wildcards are not allowed in the Namespace parameter of the Get-WMIObject cmdlet.
			try
			{
				$nameSpaceName = get-wmiobject -Namespace root\Microsoft\SQLServer -Class __Namespace -ComputerName $server -ErrorAction SilentlyContinue -Credential $domainCred | Where-Object { $_.Name -like "ComputerManagement*" } | Select Name
				$nameSpaceString = "ROOT\Microsoft\SqlServer\" + $nameSpaceName.Name
				$instanceArray = get-wmiobject -Namespace $nameSpaceString -class ServerNetworkProtocol -ComputerName $server -ErrorAction SilentlyContinue -Credential $domainCred | Where-Object { $_.ProtocolName -eq "Tcp" } | select PSComputerName, InstanceName
			}
			catch
			{
				Write-Host "No SQL instances found in WMI." -ForegroundColor Cyan
			}
			
			# Iterate through each SQL instance on the target server and return the object back to the main script.
			
			
			foreach ($instance in $instanceArray)
			{
				#Check to see if the SQL service is running as the default instance.
				
				if ($instance.InstanceName -eq "MSSQLSERVER")
				{
					$instanceName = $server
				}
				# Skip over any SQL Express instances.
				elseif ($instance.DisplayName -match "SQLEXPRESS")
				{
					Write-Host "SQL Express instance...skipping..."
					break;
				}
				else
				{
					# $instanceName = "$Computername\" + ($instance.Name).Replace("MSSQL$","")
					$instanceName = "$server\" + $instance.InstanceName
					# Write-Host $instanceName -ForegroundColor Green
				}
				
				$instances += $instanceName
			}
			
			$instances
			
		} # End Script block
	     
		$Throttle = 8
		$SQLInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	
		$SQLRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$SQLInitialSessionState,$Host)
		$SQLRunspacePool.Open()
		$SQLJobs = @()
	
	    foreach ($server in $ComputerNames)
		{
			if (-not $domainCredential)
			{
				$SQLJob = [powershell]::Create().AddScript($getSQLInstanceScript).AddArgument($server).AddArgument($parent)
				$SQLJob.RunspacePool = $SQLRunspacePool
				$SQLJobs += New-Object PSObject -Property @{
					Pipe    = $SQLJob
					Result  = $SQLJob.BeginInvoke()
				}
			}
			else
			{
				$SQLJob = [powershell]::Create().AddScript($getSQLInstanceScriptDomain).AddArgument($server).AddArgument($parent).AddArgument($domainCredential)
				$SQLJob.RunspacePool = $SQLRunspacePool
				$SQLJobs += New-Object PSObject -Property @{
					Pipe	 = $SQLJob
					Result   = $SQLJob.BeginInvoke()
				}
			}
		}
		
		Write-Host "Getting SQL configuration..." -NoNewline -ForegroundColor Green
	
		Do
		{
			Write-Host "." -NoNewline -ForegroundColor Green
			Start-Sleep -Milliseconds 200
		} while ($SQLJobs.Result.IsCompleted -contains $false)
	
		ForEach ($SQLJob in $SQLJobs) 
		{       
			$instanceNames += $SQLJob.Pipe.EndInvoke($SQLJob.Result)
		}
	
		Write-Host "All jobs completed!" -ForegroundColor Green
	
		$SQLRunspacePool.Close()
		$SQLRunspacePool.Dispose()
	
		return $instanceNames
	}
	 
}
#endregion Source: Get-SQLInstances02.ps1

#region Source: CombineSQLReportTools\Functions\Get-SQLVersion.ps1
function Invoke-Get-SQLVersion_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Get-SQLVersion function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Returns the running configuration of a SQL Instance.
	#    Usage: 
	#           - Source the function and pass the instance name as a parameter.
	#           - This script also uses dbatools PowerShell module.
	#
	#    Examples:
	#               . .\Get-SQLVersion.ps1
	#
	#               Get-SQLVersion -instanceName SERVER\Instance -SQLCredential (Get-Credential)
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Get-SQLVersion
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$instanceNames,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$SQLCredential,
			[parameter(Mandatory = $false, ValueFromPipeline = $True)]
			$domainCredential
	  )
		
		$parent = Split-Path -Path $PSScriptRoot -Parent
		
		Write-Host "Getting SQL Version output..." -NoNewline -ForegroundColor Green
	
	  $SQLConfigScript = {
			
			Param ($instance,
				$parent,
				$sqlCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
				
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			# If the logged on user credentials fail, test using SQL creds.
			
			if (-not $testDBAConnectionSession)
			{
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL or session credentials." -ForegroundColor Red
				}
			}
			
			if (($testDBAConnectionSession -and $testDBAConnectionSQL) -or ($testDBAConnectionSession -and !($testDBAConnectionSQL)))
	        {
	            # If the connection to the SQL instance is successful, call the Get-SQLData function.       
	            # Get-SqlData -instanceName $instance -Path $clSQLDataxlsxReportPath -SQLQueryFile $SQLStatsQuery
	          
	            $config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog,  MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
	            
	            # Add the SQL configuration to the global variable.
	            #$sqlConfig = Get-DbaSpConfigure -SqlInstance $instance
	            # $sqlVersionConfig += $config
	            
	            
	        }
	        elseif (!($testDBAConnectionSession) -and $testDBAConnectionSQL)
	        {
	            # If the connection to the SQL instance is successful, call the Get-SQLData function.       
	            # Get-SqlData -instanceName $instance -Path $clSQLDataxlsxReportPath -SQLQueryFile $SQLStatsQuery -Credential $sqlCred
	          
	            $sqlObj.ConnectionContext.LoginSecure=$false
	            $sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
	            $sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
	                
	            $config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog,  MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
	              
	            # Add the SQL configuration to the global variable.
	            # $sqlConfig = Get-DbaSpConfigure -SqlInstance $instance -SQLCredential $sqlCred
	            # $sqlVersionConfig += $config
	            
	           
	        }        
	        else
	        {
	            $errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
	            $testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
	            Write-host $testConnectMsg -foregroundcolor "magenta"
	            # $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$config
		} # End script block
		
		$SQLConfigScriptDomain = {
			
			Param ($instance,
				$parent,
				$sqlCred,
				$domainCred)
			
			Import-module "$parent\Modules\dbatools\dbatools.psm1"
			
			# First, let's create a SQL Management Object to test connectivity.
			
			$sqlObj = new-object ('Microsoft.SqlServer.Management.Smo.Server') $instance
			
			# First, test connectivity to the specified SQL instance using the logged on user credentials
			
			try
			{
				# $testDBAConnectionSession = Test-DbaConnection -sqlinstance $instance
				$testDBAConnectionSession = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
				Write-Host "Successfully connected to $instance using logged on session." -ForegroundColor Green
				
			}
			catch
			{
				Write-Host "No connection could be made to $instance using local session credentials. Attempting to use SQL credentals." -ForegroundColor Yellow
			}
			
			if (-not $testDBAConnectionSession)
			{
				# If the logged on user credentials fail, test using SQL creds.
				
				try
				{
					$sqlObj.ConnectionContext.LoginSecure = $false
					$sqlObj.ConnectionContext.set_Login($sqlCred.UserName)
					$sqlObj.ConnectionContext.set_SecurePassword($sqlCred.Password)
					$testDBAConnectionSQL = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using SQL credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using SQL credentials. Attempting to use provided Domain credentals." -ForegroundColor Yellow
				}
			}
			
			if ((-not $testDBAConnectionSession) -and (-not $testDBAConnectionSQL))
			{
				# Also, we're going to test domain credentials, if they were specified.
				
				try
				{
					# We need to transform the passed in domain credentials, as the SMO objects only accept usernames as USER@DOMAIN format.
					$user = $domainCred.UserName.Split("\")
					$username = "$($user[1])@$($user[0])"
					
					$sqlObj.ConnectionContext.LoginSecure = $true
					$sqlObj.ConnectionContext.ConnectAsUser = $true
					$sqlObj.ConnectionContext.ConnectAsUserName = $username
					$sqlObj.ConnectionContext.ConnectAsUserPassword = $domainCred.GetNetworkCredential().Password
					
					$testDBAConnectionDomain = $sqlObj.ConnectionContext.ExecuteWithResults("select @@version")
					Write-Host "Successfully connected to $instance using provided Domain credentials." -ForegroundColor Green
				}
				catch
				{
					Write-Host "No connection could be made to $instance using provided Domain credentials. Please verify your credentials." -ForegroundColor Red
				}
			}
			
			if ($testDBAConnectionSession)
			{
				$config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog, MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
			}
			elseif ($testDBAConnectionSQL -and (-not $testDBAConnectionDomain))
			{
				$config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog, MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
			}
			elseif ((-not $testDBAConnectionSQL) -and $testDBAConnectionDomain)
			{
				$config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog, MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
			}
			elseif ($testDBAConnectionSQL -and $testDBAConnectionDomain)
			{
				$config = $sqlObj | select Name, Edition, BuildNumber, Product, ProductLevel, Version, IsClustered, Processors, PhysicalMemory, DefaultFile, DefaultLog, MasterDBPath, MasterDBLogPath, BackupDirectory, ServiceAccount, InstanceName
			}
			else
			{
				$errorDateTime = get-date -f MM-dd-yyyy_hh.mm.ss
				$testConnectMsg = "<$errorDateTime> - No connection could be made to " + $instance + ". Authentication or network issue?"
				Write-host $testConnectMsg -foregroundcolor "magenta"
				# $testConnectMsg | Out-File -FilePath $failedConnections -Append
			}
			
			Clear-Variable sqlObj
			
			$config
		} # End script block
	
	  
	  $Throttle = 8
	  $sqlConfigInitialSessionState =[System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
	  $sqlConfigRunspacePool = [RunspaceFactory]::CreateRunspacePool(1,$Throttle,$sqlConfigInitialSessionState,$Host)
	  $sqlConfigRunspacePool.Open()
	  $sqlConfigJobs = @()
	
	  foreach ($instance in $instanceNames)
		{
			if (-not $domainCredential)
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScript).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe    = $sqlConfigJob
					Result  = $sqlConfigJob.BeginInvoke()
				}
			}
			else
			{
				$sqlConfigJob = [powershell]::Create().AddScript($SQLConfigScriptDomain).AddArgument($instance).AddArgument($parent).AddArgument($SQLCredential).AddArgument($domainCredential)
				$sqlConfigJob.RunspacePool = $sqlConfigRunspacePool
				$sqlConfigJobs += New-Object PSObject -Property @{
					Pipe	 = $sqlConfigJob
					Result   = $sqlConfigJob.BeginInvoke()
				}
			}
		}
	
	  Do
	  {
	    Write-Host "." -NoNewline -ForegroundColor Green
	    Start-Sleep -Milliseconds 200
	  } while ($sqlConfigJobs.Result.IsCompleted -contains $false)
	
	  $sqlConfig = @()
	
	  ForEach ($sqlConfigJob in $sqlConfigJobs) 
	  {     
	    $sqlConfig += $sqlConfigJob.Pipe.EndInvoke($sqlConfigJob.Result)
	  }
	
	  Write-Host "All jobs completed!" -ForegroundColor Green
	
	  $sqlConfigRunspacePool.Close()
	  $sqlConfigRunspacePool.Dispose()
	
	  return $sqlConfig  
	  
	}
}
#endregion Source: Get-SQLVersion.ps1

#region Source: CombineSQLReportTools\Functions\Test-SQLBP.ps1
function Invoke-Test-SQLBP_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: Test-SQLBP function
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         Tests for SQL Best Practices.
	#    Usage: 
	#           - Source the function and pass the required parameters.
	#           - Also requires a custom made or the included .sql file.
	#           - This script also uses the ImportExcel PowerShell module.
	#
	#    Examples:
	#               . .\Test-SQLBP.ps1 -InstanceName <INSTANCE> -ComputerName <SERVER> | ForEach-Object ($_. | ft *)
	#
	#               
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	function Test-SQLBP
	{
	
	  # This is the -instance.Name parameter passed from the PS_SQL_DB_Info.ps1 script, hence the 'ValueFromPipeline' definition.
	  Param(
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)] $instanceName,
	      [parameter(Mandatory=$true,ValueFromPipeline=$True)] $ComputerName,
	      [parameter(Mandatory=$false,ValueFromPipeline=$True)] $Credential,
	      [parameter(Mandatory=$false,ValueFromPipeline=$True)] $IsClustered
	  )
	
	  # Create variable that we will populate with the resultant set of data from the SQL queries.
	  
	  write-host "Instance name is $instanceName" -ForegroundColor Green
	  
	  if ($Credential -ne $null)
	  {
	    Write-Host "Testing with SQL credentials." -ForegroundColor Red
	    Write-host $Credential.UserName
	    $maxMemory = Test-DbaMaxMemory -SQLInstance $instanceName -SQLCredential $Credential
	    $tempDBConfig = Test-DBATempDbConfiguration -SQLInstance $instanceName -SQLCredential $Credential
	    if ($IsClustered -eq $true)
	    {
	      Write-Host "Instance is clustered. Using Host Name $ComputerName" -ForegroundColor Yellow
	    }
	    else
	    {
	      Write-Host "Using Host Name $ComputerName" -ForegroundColor Green
	      $dbDiskAllocation = Test-DBADiskAllocation -ComputerName $ComputerName -SQLCredential $Credential 
	      $powerPlan = Test-DbaPowerPlan -ComputerName $ComputerName      
	    }
	    return $maxMemory,$tempDBConfig,$dbDiskAllocation,$powerPlan  
	  }
	  else
	  {
	    $maxMemory = Test-DbaMaxMemory -SQLInstance $instanceName
	    $tempDBConfig = Test-DBATempDbConfiguration -SQLInstance $instanceName
	    if ($IsClustered -eq $true)
	    {
	      Write-Host "Instance is clustered. Using Host Name $ComputerName" -ForegroundColor Yellow
	    }
	    else
	    {
	      Write-Host "Using Host Name $ComputerName" -ForegroundColor Green
	      $dbDiskAllocation = Test-DBADiskAllocation -ComputerName $ComputerName
	      $powerPlan = Test-DbaPowerPlan -ComputerName $ComputerName
	    }
	    
	    return $maxMemory,$tempDBConfig,$dbDiskAllocation,$powerPlan
	  }
	  
	  
	}
}
#endregion Source: Test-SQLBP.ps1

#region Source: CombineSQLReportTools\Functions\Test-TCPport.ps1
function Invoke-Test-TCPport_ps1
{
	function Test-TCPport 
	{
	    Param([parameter(Mandatory=$true,ValueFromPipeline=$True)][string[]]$ComputerName,
	            [parameter(Mandatory=$true,ValueFromPipeline=$True)]$TCPport
	    )
	
	    $requestCallback = $state = $null
	    $client = New-Object System.Net.Sockets.TcpClient
	    $beginConnect = $client.BeginConnect($ComputerName,$TCPport,$requestCallback,$state)
	    Start-Sleep -Milliseconds 2000
	    if ($client.Connected) 
	    {
	        $open = $true
	    } 
	    else
	    {
	        $open = $false            
	    }
	
	    $client.Close()
	        
	    [pscustomobject]@{hostname=$ComputerName;port=$TCPport;open=$open}
	}
}
#endregion Source: Test-TCPport.ps1

#region Source: CombineSQLReportTools\IncludeMe.ps1
function Invoke-IncludeMe_ps1
{
	#######################################################################################################################################
	#
	#
	#
	#    Script: SQL Server Reporting Script Include file
	#    Author: Andy DeAngelis
	#    Descrfiption: 
	#         When adding new functions or modules for the main PS_SQL_DB_Info script to use, source/import them here.
	#
	#
	#
	#````Note: Powershellv3 or higher is needed.
	#######################################################################################################################################
	
	# Import the dbatools module, which can be downloaded from dbatools.io.
	
	Import-Module -Name "$PSScriptRoot\Modules\dbatools\dbatools.psm1" -Scope Local -PassThru
	
	# Import the ImportExcel module, which can be downloaded from https://github.com/dfinke/ImportExcel.
	
	Import-Module -Name "$PSScriptRoot\Modules\ImportExcel\ImportExcel.psm1" -Scope Local -PassThru
	
	# Source the Get-SQLInstances02 function. The included Get-SQLInstance cmdlet is lacking, and it requires the SQL Cloud adapter to run.
	# The SQL Cloud Adapter is primarily for Azure instances, and does not exist in the feature pack for SQL 2016.
	 
	. "$PSScriptRoot\Functions\Get-SQLInstances02.ps1"
	. "$PSScriptRoot\Functions\Get-ClusteredSQLInstances.ps1"
	
	# Source the SQL Specific functions.
	
	. "$PSScriptRoot\Functions\Get-SQLData.ps1"
	. "$PSScriptRoot\Functions\Get-SQLConfig.ps1"
	. "$PSScriptRoot\Functions\Test-SQLBP.ps1"
	. "$PSScriptRoot\Functions\Get-SQLVersion.ps1"
	. "$PSScriptRoot\Functions\Get-SQLAGConfig.ps1"
	. "$PSScriptRoot\Functions\Get-InstalledSQLServices.ps1"
	
	# Source the Get-ServerConfig function
	
	. "$PSScriptRoot\Functions\Get-ServerConfig.ps1"
	. "$PSScriptRoot\Functions\Get-IsAlive.ps1"
	
	# Include the MS Clustering functions.
	
	. "$PSScriptRoot\Functions\Get-IsClustered.ps1"
	. "$PSScriptRoot\Functions\Get-ClusterNodes.ps1"
	. "$PSScriptRoot\Functions\Get-ClusterConfig.ps1"
}
#endregion Source: IncludeMe.ps1

#region Source: CombineSQLReportTools\Launcher.ps1
function Invoke-Launcher_ps1
{
	write-host $PSScriptRoot -ForegroundColor Green
	
	# $script = $PSScriptRoot + "\PS_SQL_DB_Info.ps1"
	# $argumentList = "-executionpolicy bypass -windowstyle normal -nologo -file $script"
	
	$servers = Get-Content "C:\Scripts\Projects\SQLCombinedReports\CombineSQLReportTools\myservers.txt"
	$reports = "C:\Scripts\Reports"
	$sqlCred = Get-Credential
	$script = "$PSScriptRoot\CombineSQLReportTools\PS_SQL_DB_Info.ps1 -ServerFileName $servers -ReportPath $reports -SQLCredentials $sqlCred"
	$argumentList = "-executionpolicy bypass -windowstyle normal -nologo -file $script"
	
	$message = "The domain account you specify must be a member of the local Administrators group on each server."
	
	Write-Host $script -ForegroundColor Green
	
	# Start-Process powershell -Credential $creds -ArgumentList '-noprofile -command &(Start-Process $script -Verb runAs)'
	
	Start-Process powershell -Credential (Get-Credential -Message $message) -WorkingDirectory $PSScriptRoot -ArgumentList $argumentList -NoNewWindow
	
}
#endregion Source: Launcher.ps1

#region Source: CombineSQLReportTools\ScheduledTask.ps1
function Invoke-ScheduledTask_ps1
{
	$ServerFileName = "C:\Scripts\test\myservers.txt"
	$ReportPath = "C:\Scripts\Test\"
	$sqlCred = "C:\Scripts\test\sqlCred.XML"
	$domainCred = "C:\Scripts\test\domainCred.XML"
	
	$scriptFile = "PS_SQL_DB_Info.ps1 -ServerFileName $ServerFileName -ReportPath $ReportPath -SQLCredXMLFile $sqlCred -DomainCredXMLFile $domainCred -SaveCreds -RunSilent"
	
	$argumentList = "-executionpolicy bypass", "-mta", "-noninteractive", "-windowstyle normal", "-nologo", "-file $scriptFile"
	
	# Start-Process powershell -WorkingDirectory $PSScriptRoot -ArgumentList $argumentList -NoNewWindow
	
	.\PS_SQL_DB_Info.ps1 -ServerFileName $ServerFileName -ReportPath $ReportPath -SQLCredXMLFile $sqlCred -DomainCredXMLFile $domainCred -SaveCreds -RunSilent
}
#endregion Source: ScheduledTask.ps1

#Start the application
Main ($CommandLine)
